# File: `async_example.chor`
feature "Async operations example"

settings {
  timeout_seconds = 15
}

actors: Terminal, Web, FileSystem

# Start a simple HTTP server in the background on the main thread so all scenarios can hit it.
background {
    Terminal run "python3 -m http.server 8000 &"
    # give server a moment to start
    wait >= 0.5s
}

# Run tests in parallel to exercise async behavior
parallel scenario "Concurrent requests and background jobs" {
    test Req1 "HTTP GET to root" {
        given:
            Test can_start
        when:
            Web http_get "http://localhost:8000/"
        then:
            Web response_status_is 200
            Web response_time is_below 2s
    }

    test LongJob "Background job finishes and writes marker" {
        given:
            Test can_start
        when:
            # Redirect background job output to a file so the runner can check it
            Terminal run "bash -c 'sleep 3; echo long-job-done > /tmp/longjob.out 2>&1' &"
        then:
            # Check the file for the marker instead of terminal output
            FileSystem file_contains "/tmp/longjob.out" with_content "long-job-done"
    }

    after {
        # cleanup: kill any background python server (best-effort)
        Terminal run "pkill -f 'http.server' || true"
        Terminal run "rm -f /tmp/longjob.out"
    }
}

{
  "export_date": "2025-09-15T04:59:35.360406Z",
  "note_count": 22,
  "notes": [
    {
      "key": "changelog-blogpost",
      "title": "CHANGELOG.md",
      "tags": [
        "blogpost"
      ],
      CHANGELOG.md.tmp && mv CHANGELOG.md.tmp CHANGELOG.md\n```\n\nIt generates the new section, adds a blank line, and then appends the old content‚Äîall in one step.\n\n## Wrapping Up\n\nThe new `changelog` command is another step in `tbdflow`'s mission to be a \"friendly assistant\" for your TBD workflow. \nIt takes one more repetitive task off your plate, so you can spend more time writing code.\n\nTake a look at `tbdflow`'s [CHANGELOG](https://github.com/cladam/tbdflow/blob/main/CHANGELOG.md), generated by the `changelog` command üôÇ\n\n",
    "created_at": "2025-08-20T22:01:06.094173Z",
    "modified_at": "2025-08-20T22:01:06.094174Z"
    },
    {
      "key": "choreo-reference",
      "title": "choreo-reference",
      "tags": [],
      ${FILENAME}\"  \n```\n\n",
    "created_at": "2025-09-12T12:03:44.571663Z",
    "modified_at": "2025-09-12T12:03:44.571664Z"
    },
    {
      "key": "choreo-test",
      "title": "choreo-test",
      "tags": [],
      "content": "# My quick medi note",
      "created_at": "2025-09-15T04:59:35.055656Z",
      "modified_at": "2025-09-15T04:59:35.055656Z"
    },
    {
      "key": "cladam_github_io_readme",
      "title": "cladam_github_io_readme",
      "tags": [],
      "content": "## Personal Site & Blog - `cladam.github.io`\n\nThis repository contains the source code for my personal website and blog, which is built with Jekyll and hosted on GitHub Pages. You can view the live site at [cladam.github.io](https://cladam.github.io).\n\n## About This Project\n\nEvery developer needs a home on the web; a space to share ideas, document experiments, and showcase what they‚Äôre building. This site is my space. I wanted something clean, content-first, and flexible enough to host both long-form writing and structured documentation for my open-source projects.\n\n## The Technology\n\nThe site is built using Jekyll, a static site generator. The theme is a custom one, built from scratch with a clean, content-focused design inspired by the `Lanyon` theme. It features a persistent sidebar for easy navigation and a simple, readable layout for both blog posts and project documentation.\n\n## Still Evolving\n\nThis site is a work in progress, and that‚Äôs the point. I built it by making small, testable changes and letting each improvement inform the next. That same philosophy, _make it work, make it better_, is what shapes the tools I build and the workflows I advocate for.\n",
      "created_at": "2025-08-14T12:41:54.729134Z",
      "modified_at": "2025-08-14T12:41:54.729137Z"
    },
    {
      "key": "jb-marketplace-token",
      "title": "jb-marketplace-token",
      "tags": [],
      "content": "perm-Y2xhZXMuYWRhbXNzb24=.OTItMTMzMTQ=.sAjzENfqrMjQrJEqJhgzwbiIdUGsvT",
      "created_at": "2025-08-31T08:49:16.318768Z",
      "modified_at": "2025-08-31T08:49:16.318768Z"
    },
    {
      "key": "linkedin-tbdflow",
      "title": "post",
      "tags": [],
      "content": "I think dry-runs are great, (\"torrsimma\" in Swedish.)\n\nEspecially in our field, it's very useful to see what will be executed before you run a command.\n\nSure, we can look at the source and try to deduce the flow, but better yet, why not show the user what will actually happen when they press [Enter]?\n\nThat's why I added a --dry-run flag to tbdflow, with it you can see what Git commands it would run, without making any changes.\n\nIt‚Äôs both a safety net and a learning tool. I wrote a short post about how it works and why I think it matters:\nüîó https://cladam.github.io/2025/08/23/dry-run/\n\n#tbdflow #trunkbaseddevelopment #git #cli #developerexperience\n\n\n---\n\nI'm having fun developing tbdflow using Rust, it's pretty easy to build robust CLI tools using clap.\n\ntbdflow is a command-line tool designed to streamline and safeguard your Git workflow for Trunk-Based Development.\n\nI built it to help teams adopt TBD in an easier way.\n\nCheck it out at https://lnkd.in/dvagsyPY\n\n---\n\nHow do you showcase a CLI tool in a README? Static code blocks are fine for reference, but they don't show the tool in action.\n\nI wanted to bring my examples for tbdflow to life, so I created an animated GIF to demonstrate its core workflows. \n\nI wrote a short blog post about how I did it, the tool I used, and how you can create the same kind of demos for your own projects:\n üîó https://lnkd.in/d9KZjr2P\n\nhashtag#tbdflow hashtag#cli hashtag#documentation hashtag#developerexperience\n\n---\n\nThanks for all the feedback and interest in tbdflow!\nIt‚Äôs been great to see the project pass 2,000+ downloads on crates-io, and I‚Äôm excited to keep improving it with your input.\n\nI‚Äôve been working on making it an even better assistant for Trunk-Based Development workflows. The latest version is now live, with a few key updates:\n\nüîπ Stay in sync\nA new sync command gives you a quick overview of your repo. Pulling the latest changes, showing recent history, and checking your local status in one go.\n\nüîπ Keep branches fresh\nsync now also warns you about stale branches that haven‚Äôt been updated in over a day, helping you stick to TBD‚Äôs ‚Äúshort-lived branches‚Äù principle.\n\nüîπ Easy to get started\nA new and improved init command has been added. It sets up your repo with sensible defaults, creating .dod.yml and .tbdflow.yml if they don‚Äôt exist, and even initialising the Git repo for you if needed.\n\nüîπ Improved docs and visibility\nI‚Äôve launched a GitHub Page to provide clearer, more accessible documentation and highlight the project‚Äôs goals.\n\nüìÑ Check it out here: https://lnkd.in/d3GMsTj7\nüîó Original post: https://lnkd.in/dDB3hQfB \n\nhashtag#git hashtag#cli hashtag#rust hashtag#tbd hashtag#continuousdelivery hashtag#opensource\n\n---\n\nTrunk-Based Development (TBD) is one of the best ways to improve software delivery performance.\nIt supports fast feedback, cleaner integration, and better collaboration. It‚Äôs also the foundation for Continuous Integration and Continuous Delivery.\n\nTBD promotes committing to trunk (main) daily, ideally multiple times a day. But adopting this workflow isn‚Äôt always easy. Remembering the right Git commands, formatting commits, branch cleanup and pushing safely can slow you down. It‚Äôs easy to lose momentum when the workflow feels clunky.\n\nTo make the right way the easy way, I‚Äôve been building a small command-line tool in my spare time: tbdflow. \n\nIt‚Äôs a simple wrapper around Git that:\n‚úÖ Codifies a safe, opinionated TBD workflow\n‚úÖ Encourages daily commits to main\n‚úÖ Reduces errors and cognitive load\n‚úÖ Supports short-lived branches when you need them\n\nI originally started with a few local bash aliases to handle git pull-commit-push, but wanted something more robust and shareable.\n\nSo if you‚Äôre practising TBD (or curious to try it), check it out:\nüîó github.com/cladam/tbdflow\n\nFeedback and contributions welcome!\n\nhashtag#devops hashtag#trunkbasedevelopment hashtag#ContinuousDelivery hashtag#devex hashtag#opensource\n\n",
      "created_at": "2025-08-23T14:11:31.038099Z",
      "modified_at": "2025-08-23T15:08:56.142391Z"
    },
    {
      "key": "matteo",
      "title": "matteo",
      "tags": [],
      "content": "# Matteo is awesome\n",
      "created_at": "2025-09-08T12:34:23.601180Z",
      "modified_at": "2025-09-08T12:34:23.601182Z"
    },
    {
      "key": "medi",
      "title": "medi",
      "tags": [
        "medi"
      ],
      "content": "medi is a fast, editor-centric, command-line notes manager",
      "created_at": "2025-09-01T22:40:01.097585Z",
      "modified_at": "2025-09-01T22:40:01.097585Z"
    },
    {
      "key": "medi-blogpost",
      "title": "medi-blogpost",
      "tags": [],
      _posts/2025-08-12-why-medi.md\n# Commit using tbdflow\ntbdflow commit -t feat -s blog -m \"add blog entry about medi\"\n```\n\n",
      "created_at": "2025-08-14T12:41:54.736451Z",
      "modified_at": "2025-08-14T12:41:54.736451Z"
    },
    {
      "key": "medi-perf-test",
      "title": "medi-perf-test",
      "tags": [
        "blog",
        "medi"
      ],
      "content": "---\nlayout: post\ntitle: Blazing fast search\n---\n\nWhen I started building `medi`, my command-line notes manager, the goal was a fast, local-first workflow. But how fast is _fast_? Could it stay fast at scale? With a database of thousands of notes, would search grind to a halt?\n\nA user on Reddit asked the same question, so I decided to find out. At first, I hacked together a quick `bash` script, but I wanted something more solid in the test suite. The results were better than I expected.\n\n### The test\n\nI wrote a simple performance test that does three things:\n\n1. **Generate Data**: Create 1,000 notes, each \\~50KB of random text (\\~50MB total).\n2. **Build Index**: Run `medi reindex` to build a full-text search index from scratch.\n3. **Run Search**: Time a ‚Äúcold‚Äù search for a single word, including application startup.\n\n### The results\n\nThe numbers speak for themselves:\n\n* **Reindexing 1,000 notes (50MB of text):** `2.7 seconds`\n* **Searching the entire database:** `106 milliseconds`\n\n\n### Analysis\n\nRebuilding a search index for 50MB of text in under three seconds is a great sign, even if the index gets corrupted, it can be rebuilt in no time.\n\nThe real win is search speed. That 106ms includes everything: starting the binary, loading the index from disk, parsing the query, running the search, and printing the result. The actual search is probably in the single-digit milliseconds. From the user‚Äôs perspective it's instant.\n\nThis test also validates the architecture choice: `sled` for storage + `tantivy` for search is reliable and **fast**. It gives me confidence that `medi` will stay responsive with 10,000 notes as it is with just 10.\n\nIf you‚Äôre building a Rust app that needs local search, I can highly recommend [`tantivy`](https://github.com/quickwit-oss/tantivy). You can also check out `medi` and its implementation on [my GitHub](https://github.com/cladam/medi).\n\n",
      "created_at": "2025-09-06T19:45:01.816820Z",
      "modified_at": "2025-09-06T19:45:01.816821Z"
    },
    {
      "key": "medi-readme",
      "title": "medi-readme",
      "tags": [
        "medi",
        "README"
      ],
      "content": "<div align=\"center\">\n\n<p align=\"center\">\n  <img src=\"assets/medi-logo.png\" alt=\"medi logo\" width=\"200\"/>\n</p>\n\n<p align=\"center\">\n  <b>‚ö° A speedy CLI Markdown Manager ‚ö°</b><br/>\n  Lightweight ‚Ä¢ Local-first ‚Ä¢ Editor-friendly\n</p>\n\n[![Crates.io](https://img.shields.io/crates/v/medi.svg)](https://crates.io/crates/medi)\n[![Downloads](https://img.shields.io/crates/d/medi.svg)](https://crates.io/crates/medi)\n\n</div>\n\n\n## About\n\n**[[medi]] is a fast, editor-centric, command-line notes manager.**\n\n`medi` is a simple and powerful tool for creating and managing your notes, articles, and documentation directly from the terminal. It's built for developers, writers, and anyone who loves the speed and focus of a command-line workflow.\n\n![A terminal running medi commands](docs/medi.gif \"A demo of medi\")\n\n## Philosophy\n\n`medi` is built on a few guiding principles:\n\n- **CLI-first**: Everything is done through the terminal. No GUIs or TUIs, no distractions.\n- **Editor-centric**: Your text editor (`$EDITOR`) is where you write. `medi` gets you there quickly and saves your work securely.\n- **Local & private**: All content is stored on your local machine in a high-performance embedded database. No cloud services, no network access.\n- **Zero-config start**: Install it and start writing immediately.\n\n## Features ‚ú®\n\n- **Create & Manage Notes**: Quickly create new notes using a simple command (`medi new <note-key>`). You can add content directly with a flag, pipe it from other commands, or open your favorite text editor for more detailed entries.\n- **Powerful Organisation**: Keep your notes tidy with tags. Add multiple tags when creating a note (`--tag`) and easily add or remove them later (`medi edit --add-tag ...`).\n- **Integrated Task Management**: Turn your notes into actionable to-do lists. Add tasks to any note (`medi task add ...`), list all your pending items, mark them as complete (`medi task done ...`), and set priorities to focus on what's important.\n- **Full-text Search**: Instantly find what you're looking for with a powerful search command (`medi search <term>`) that scans the content of all your notes.\n- **Import & Export**: `medi` is not a data silo. You can easily import entire directories of Markdown files to get started, and export all your notes back to Markdown or JSON at any time.\n- **List & Review**: Get a clean, sorted list of all your notes (`medi list`) or view the content of any specific note (`medi get <note-key>`).\n- **Finding Connections & Notes**: Use `[[wiki-like]]` syntax to link back to a note, and use a fuzzy finder to quickly find and edit a note by its key.\n- **Colourful & Clear Output**: Uses coloured output to clearly distinguish between success messages, information, warnings, and errors.\n\n## How It Works, DB as Source-of-Truth\n\n`medi` uses a database-first approach. All your notes are stored in a `sled` key-value database, making access fast and reliable. This database is the single source of truth.\n\nTo version control your work with Git, `medi` provides a simple and deliberate workflow:\n\n- **Write**: Use `medi new` and `medi edit` to manage your notes.\n- **Export**: Run `medi export ./my-notes` to write all your notes to a local directory as `.md` files.\n- **Commit**: Use Git to commit the exported directory, giving you a complete, version-controlled snapshot of your work.\n\n### Installation\n\nYou need [Rust and Cargo](https://www.rust-lang.org/tools/install) installed.\n\n#### Installing from crates.io\n\nThe easiest way to install `medi` is to download it from [crates.io](https://crates.io/crates/medi). You can do it using the following command:\n\n```bash\ncargo install medi\n```\n\nIf you want to update `medi` to the latest version, execute the following command:\n\n```bash\nmedi update\n```\n\n#### Building from source\n\nAlternatively you can build `medi` from source using Cargo:\n\n```bash\ngit clone https://github.com/cladam/medi.git\ncd medi\nsudo cargo install --path . --root /usr/local\n```\n\n## Configuration\n\nOn the first run, `medi` will automatically create a default configuration file at the standard location for your operating system:\n\n  * **macOS**: `~/Library/Application Support/medi/config.toml`\n  * **Linux**: `~/.config/medi/config.toml`\n  * **Windows**: `C:\\Users\\<user>\\AppData\\Roaming\\medi\\config.toml`\n\nYou can edit this file to customize `medi`'s behaviour.\n\n### Example `config.toml`\n\n```toml\n# Path to the database file.\n# You can change this to store your notes in a different location,\n# for example, inside a cloud-synced folder like Dropbox.\ndb_path = \"/Users/cladam/Library/Application Support/medi/medi_db\"\n\n# Default directory for the `medi export` command.\n# If this is set, you can run `medi export` without specifying a path.\n# Leave it as an empty string (\"\") if you don't want a default.\ndefault_export_dir = \"/Users/cladam/Documents/medi_backups\"\n```\n\n## Usage\n\n### Creating and Editing Notes\n\n* **Create a new note**\n\n  `medi` provides three ways to create a new note:\n\n  1.  **Interactively (default)**: Opens your default editor for long-form content.\n      ```bash\n      medi new \"my-long-article\"\n      # With tags: Add tags to your note for better organisation.\n      medi new \"my-long-article\" --tag tag1 --tag tag2\n      # With a title: Specify a title for your note.\n      medi new \"my-long-article\" --title \"My Long Article\"\n      ```\n\n  2.  **With a direct message**: Perfect for quick, one-line notes.\n      ```bash\n      medi new quick-idea -m \"Remember to buy milk\"\n      ```\n\n  3.  **From a pipe**: Use the output of other commands as your note content.\n      ```bash\n      echo \"This is a note from a pipe\" | medi new piped-note\n      ```\n\n* **Edit an existing note**\n  ```bash\n  medi edit \"my-long-article\"\n  \n  # Add tags to a note\n  medi edit \"my-long-article\" --add-tag tag1 --add-tag tag2\n  \n  # Remove tags from a note\n  medi edit \"my-long-article\" --rm-tag tag1 --rm-tag tag2\n  ```\n\n### Using Templates üìù\n\n`medi` can create new notes from predefined templates to speed up your workflow. On its first run, `medi` creates an example `meeting.md` template in the configuration directory.\n\n- **Location of templates:**\n\n    * **macOS**: `~/Library/Application Support/medi/templates/`\n    * **Linux**: `~/.config/medi/templates/`\n    * **Windows**: `%APPDATA%\\medi\\templates\\`\n\n- **Create a note from a template:**\n\n  ```bash\n  medi new my-project-meeting --template meeting\n  ```\n\n- **Create your own templates:**\n  Simply add any `.md` file to your templates directory. If you create `blog.md`, you can use it with `medi new ... --template blog`.\n\n\n### Finding, Viewing & Listing Notes\n\n‚ö†Ô∏è This feature is not supported on Windows.\n\n  - **Interactively find a note**\n    Open a fuzzy finder to quickly search for and edit a note by its key.\n\n    ```bash\n    medi find\n    ```\n\n    This will open an interactive TUI to help you find the note you want to edit.\n\n\n  - **Get a note's content**\n    Prints the note directly to the console. This is perfect for piping to other tools.\n\n    ```bash\n    medi get \"my-first-article\"\n\n    # Pipe to a Markdown renderer like mdcat\n    medi get \"my-first-article\" | mdcat\n\n    # Get a note in Json format\n    medi get \"my-first-article\" --json\n\n    # Get one or several notes via a tag\n    medi get --tag my-tag\n    ```\n\n  - **List all notes**\n    The `list` command provides a rich overview of your notes, including their keys and tags.\n\n    ```bash\n    medi list\n    ```\n\n    *Output:*\n\n    ```\n    - cladam_github_io_readme [#blog #project]\n    - medi-blogpost [#rust]\n    ```\n\n  - **Sort your notes**\n    You can sort the list by creation or last modification date using the `--sort-by` flag. The default is to sort alphabetically by key.\n\n    ```bash\n    # Sort by the most recently modified notes\n    medi list --sort-by modified\n\n    # Sort by when the notes were created\n    medi list --sort-by created\n    ```\n\n### Searching & Indexing\n\n`medi` includes a full-text search engine (`tantivy`) that lets you find notes by their content, title, or tags.\n\n**Search for a note**\n```bash\n# Find all notes containing the word \"rust\"\nmedi search rust\n\n# Search for a phrase\nmedi search \"database design\"\n```\n\n_Output_:\n\n```\nSearch Results:\n- medi-blogpost\n- rust-cli-ideas\n```\n\n**Rebuild the search index**\n\nIf your search index ever gets out of sync or you're setting up `medi` for the first time with an existing database, you can rebuild the entire index.\n\n```bash\nmedi reindex\n```\n\n### Deleting a Note\n\n- **Delete a note**\n  You will be prompted for confirmation.\n\n  ```bash\n  medi delete \"my-first-article\"\n\n  # Skip the confirmation prompt\n  medi delete \"my-first-article\" --force\n  ```\n\n### Versioning with Export/Import\n\n- **Export all notes to a directory**\n  Creates a version-controllable snapshot of your database.\n\n  ```bash\n  medi export ./my_notes_backup\n  cd my_notes_backup\n  tbdflow init\n  ```\n- **Export all notes to a Json document**\n\n  ```bash\n  medi export medi-export --format json\n  ```\n- **Export notes via a tag**\n\n  ```bash\n  medi export medi-export --tag my-tag\n  ```\n\n- **Import notes from a directory**\n  Restores notes from a directory of `.md` files.\n\n  ```bash\n  # By default, skips any notes that already exist\n  medi import --dir /path/to/notes\n\n  # Import a single\n  medi import --file /path/to/note.md --key my-note\n\n  # Overwrite existing notes with the imported versions\n  medi import --file /path/to/note.md --key my-note --overwrite\n  ```\n\n### Task Management\n\n`medi` includes a simple task manager to help you turn notes into actionable to-do lists.\n\n  - **Add a task to a note**\n\n    ```bash\n    medi task add my-blog-post \"Finish the conclusion section\"\n    ```\n\n  - **List all tasks**\n    \n    The list is sorted by priority and status.\n\n    ```bash\n    medi task list\n    ```\n\n    _Output:_\n\n    ```\n    Tasks:\n    [42] [Prio] ‚≠ê : Review final draft (for note 'medi-readme')\n    [43] [Open] : Add usage examples (for note 'medi-readme')\n    [44] [Done] : Write introduction (for note 'my-blog-post')\n    ```\n\n  - **Prioritise a task**\n\n    ```bash\n    medi task prio 43\n    ```\n\n  - **Complete a task**\n\n    ```bash\n    medi task done 43\n    ```\n\n  - **Delete a task**\n\n    ```bash\n    medi task delete 43\n    ```\n\n  - **Clear all tasks**\n    \n    This is a destructive action\n\n    ```bash\n    medi task reset\n    ```\n\n\n### Checking Status\n\nThe `status` command provides a high-level overview of your database or detailed statistics for a single note.\n\n  - **Get a global overview:**\n\n    ```bash\n    medi status\n    ```\n\n    _Output:_\n\n    ```\n    medi status\n      Notes: 42\n      Tasks: 8 open (3 priority)\n    ```\n\n  - **Get stats for a specific note:**\n\n    ```bash\n    medi status medi-blogpost\n    ```\n\n    _Output:_\n\n    ```\n    medi-blogpost\n      Key: medi-blogpost\n      Tags: rust, cli\n      Words: 584\n      Reading Time: ~3 minute(s)\n      Created: Mon, 12 Sep 2025 10:30:00 +0200\n      Modified: Tue, 13 Sep 2025 15:00:00 +0200\n    ```\n\n### Discover Connections\n\n  - **Find backlinks for a note**\n    Discover all the notes that link to a specific topic using `[[wiki-link]]` syntax.\n\n    ```bash\n    medi backlinks rust\n    ```\n\n    _Output:_\n\n    ```\n    Found 1 backlinks for 'rust':\n    - medi-project\n    ```\n\n### Shell Completion\n\nTo make `medi` even faster to use, you can enable shell completion. Add one of the following lines to your shell's configuration file.\n\nFor Zsh (`~/.zshrc`):\n\n```bash\neval \"$(medi generate-completion zsh)\"\n```\n\nFor Bash (`~/.bashrc`):\n\n```bash\neval \"$(medi generate-completion bash)\"\n```\n\nFor Fish (`~/.config/fish/config.fish`):\n\n```bash\nmedi generate-completion fish | source\n```\n\n## Project Roadmap üó∫Ô∏è\n\nThis section tracks the implementation status of `medi`'s features. Contributions are welcome!\n\n- [x] All core commands (new, get, list, edit, delete, import, export).\n- [x] Configuration file for settings (e.g. database path).\n- [x] Support for note metadata (tags, creation dates).\n- [x] `export` notes by tag.\n- [x] Full-text search over note content.\n- [x] Implement a `task` command for tracking the status of notes.\n- [x] Implement a simple status command\n- [x] Add a Fuzzy Finder for notes\n- [x] Add templates for different documents\n- [x] Wiki-Style Linking\n- [ ] ...\n\n",
      "created_at": "2025-08-14T12:41:54.752095Z",
      "modified_at": "2025-09-06T12:41:43.189635Z"
    },
    {
      "key": "meeting-with-rob",
      "title": "meeting-with-rob",
      "tags": [],
      "content": "# Meeting: {{ MEETING TITLE }}\n\n**Date:** {{ YYYY-MM-DD }}\n**Location:**\n**Facilitator:**\n**Notetaker:**\n\n ---\n\n## Attendees\n\n-\n\n---\n\n## Agenda\n\n1.\n2.\n\n---\n\n## Decisions Made\n\n-\n\n---\n\n## Action Items\n\n| Task | Owner | Due Date |\n| ---- | ----- | -------- |\n|      |       |          |\n|      |       |          |\n\n---\n\n## Additional Notes\n\n-",
      "created_at": "2025-08-26T21:55:28.692855Z",
      "modified_at": "2025-08-26T21:55:28.692857Z"
    },
    {
      "key": "milk",
      "title": "milk",
      "tags": [],
      "content": "buy milk",
      "created_at": "2025-09-08T12:34:56.611963Z",
      "modified_at": "2025-09-08T12:34:56.611963Z"
    },
    {
      "key": "project-tbdflow",
      "title": "project-tbdflow",
      "tags": [],
      tbdflow.1\n```\n\n### Development\n\nAll development happens at [tbdflow.git](https://github.com/cladam/tbdflow). Feedback and contributions welcome!\n\n",
    "created_at": "2025-08-23T14:40:30.091677Z",
    "modified_at": "2025-08-27T15:15:14.278022Z"
    },
    {
      "key": "project_medi",
      "title": "project_medi",
      "tags": [],
      "content": "---\nlayout: project\ntitle: \"medi\"\ntagline: \"A speedy CLI driven Markdown manager\"\n---\n\n<p align=\"center\">\n  <img src=\"/assets/images/medi-logo.png\" alt=\"medi logo\" width=\"200\"/>\n</p>\n\n### Overview\n\nA fast, editor-centric, command-line notes manager built in Rust.\n\n`medi` is a powerful tool for creating and managing your notes, articles, and documentation directly from the terminal. It's built for developers, writers, and anyone who loves the speed and focus of a command-line workflow, combining the simplicity of Markdown with the speed of an embedded database.\n\n-----\n\n## Key Features\n\n  - **Speed**: Instant access to any note, no matter how large your collection grows.\n  - **Interactive Fuzzy Finder**: Instantly find and edit any note by its key or title with an interactive `medi find` command.\n  - **Full-Text Search**: Instantly find notes by their content, title, or tags using a powerful built-in search engine.\n  - **Templates for Productivity**: Speed up repetitive writing tasks by creating new notes from custom templates.\n  - **Integrated Task Management**: Turn your notes into actionable to-do lists. Add tasks to any note (`medi task add ...`), list all your pending items, mark them as complete (`medi task done ...`), and set priorities to focus on what's important.\n  - **Status Dashboard**: Get a quick overview of your entire database with the `medi status` command.\n  - **Flexible Input**: Create notes interactively in your editor, with a one-liner `-m` flag, or by piping from other commands.\n  - **Robust Import/Export**: Easily create version-controllable snapshots of your database or import notes from disk.\n  - **Shell Completion**: Generates completion scripts for `bash`, `zsh`, and `fish` for a faster workflow.\n\n-----\n\n## Core Philosophy\n\n`medi` is built on a few guiding principles:\n\n  * **CLI-first**: Everything is done through the terminal. No GUIs, no distractions.\n  * **Editor-centric**: Your text editor (`$EDITOR`) is where you write. `medi` gets you there quickly and saves your work securely.\n  * **Local & private**: All content is stored on your local machine. No cloud services, no network access.\n  * **Zero-config start**: Install it and start writing immediately.\n\n-----\n\n## Technical Details\n\n`medi` is written in **Rust**. It uses `clap` for command-line argument parsing, `sled` for the embedded key-value database and `tantivy` for searching. For the fuzzy finding i am using the `skim` crate.\n\n[**View on GitHub ‚Üí**](https://github.com/cladam/medi)\n",
      "created_at": "2025-08-14T12:41:54.756838Z",
      "modified_at": "2025-08-27T15:06:45.808834Z"
    },
    {
      "key": "tbdflow",
      "title": "tbdflow",
      "tags": [],
      "content": "tbdflow, a Trunk-Based Development CLI",
      "created_at": "2025-09-01T19:15:55.653778Z",
      "modified_at": "2025-09-01T19:15:55.653779Z"
    },
    {
      "key": "tbdflow-contributing",
      "title": "tbdflow-contributing",
      "tags": [],
      "content": "# Contributing to `tbdflow`\n\nFirst off, thank you for considering contributing to `tbdflow`! It's an open-source project built to help developers, and your help is greatly appreciated. This document will guide you through the process.\n\n## The Philosophy\n\n`tbdflow` is an opinionated tool, and we try to follow our own advice. We practice Trunk-Based Development and use Conventional Commits. While we use Pull Requests to manage contributions from the community (the exact use case they were designed for!), we aim to keep them small, focused, and short-lived.\n\n## How to Contribute\n\nThe best way to contribute is to start a conversation first.\n\n- **Open an Issue**: Before you start writing code, please open an issue to discuss the bug you want to fix or the feature you want to add. This helps us ensure your work aligns with the project's goals and avoids duplicated effort.\n- **Fork and Branch**: Once we've discussed the approach, fork the repository and create a new, short-lived branch for your work.\n- **Write Code & Tests**: Make your changes and be sure to add or update tests to cover your work. We value a robust test suite!\n- **Submit a Pull Request**: Push your branch and open a Pull Request against the `main` branch. Please link the issue you created in the PR description.\n\n## Setting Up Your Development Environment\n\nThe Rust version (`tbdflow-rs`) is the actively developed version.\n\n- **Install Rust**: If you don't have it, install the Rust toolchain from rustup.rs.\n- **Clone the repository**:\n  ```bash\n  git clone https://github.com/cladam/tbdflow.git\n  cd tbdflow/tbdflow-rs\n  ```\n- **Build the project**:\n  ```bash\n  cargo build\n  ```\n\n### Running Tests\nWe have a suite of integration tests to ensure the tool works as expected. Before submitting your changes, please make sure all tests pass.\n\nTo run the full test suite:\n```bash\ncargo test\n```\n\n## Coding Style & Conventions\n\nWe follow the standard Rust coding style. Please run the following commands before committing to ensure your code is formatted correctly and to catch any common issues.\n\nFormat your code:\n```bash\ncargo fmt\n```\n\nRun the linter:\n```bash\ncargo clippy -- -D warnings\n```\n\n## Commit Message Guidelines\n\nWe use `tbdflow` to develop `tbdflow`, so we follow our own rules! All commit messages must follow the Conventional Commits specification. This helps us maintain a clean history and automate our release process.\n\n- Use the imperative mood: \"add feature\" not \"added feature\".\n- Start with a type: feat, fix, docs, chore, refactor, test, etc.\n- Provide a clear description.\n\nThank you again for your interest in contributing!\n",
      "created_at": "2025-08-14T12:41:54.762054Z",
      "modified_at": "2025-08-14T12:41:54.762055Z"
    },
    {
      "key": "tbdflow-dry-run",
      "title": "tbdflow-dry-run",
      "tags": [
        "blogpost"
      ],
      "content": "---\nlayout: post \ntitle: Looking under the hood with a dry-run\n---\n\nOne of the most valuable pieces of feedback I‚Äôve had about `tbdflow` came as a simple question:\n\n**‚ÄúWhat does this tool actually do if the user only knows `tbdflow` but not the workflow behind it?‚Äù**\n\nIt‚Äôs a fair point. The aim of `tbdflow` has never been to act as a magic black box. It‚Äôs meant to be a _friendly assistant with guardrails_, helping developers adopt Trunk-Based Development while still showing them what‚Äôs going on under the hood.\n\nThat‚Äôs why I‚Äôve added a new global flag: `--dry-run`.\n\n### Transparent and educational\n\nWhen you add `--dry-run` to any `tbdflow` command, the tool won‚Äôt execute anything. Instead, it prints the exact Git commands it *would* have run, in the order they‚Äôd normally run.\n\n- **Transparency**: No hidden steps, no mystery. You see exactly what `tbdflow` is doing for a `commit`, `complete`, or `sync` command. That visibility builds trust and confidence.\n- **Learning**: For anyone new to TBD, `--dry-run` doubles as a teaching tool. By exposing the Git workflow, it shows the ‚Äúwhy‚Äù behind the automation and helps developers pick up best practices faster.\n\n### How to use it\n\nFor example, if you want to see what happens when creating a new feature branch, just add the `--dry-run` flag:\n\n```bash\ntbdflow --dry-run branch --type feat --name \"new-thing\"\n```\n\nThis will show you every Git command `tbdflow` *would* run, step by step, without actually touching your repo.\n\nThe output looks like this:\n\n```\n[DRY RUN] Command would execute but no changes made\ngit rev-parse --is-inside-work-tree\n\n--- Creating short-lived branch ---\n[DRY RUN] Command would execute but no changes made\ngit status --porcelain\n\n[DRY RUN] Command would execute but no changes made\ngit checkout main\n\n[DRY RUN] Command would execute but no changes made\ngit pull --rebase --autostash\n\n[DRY RUN] Command would execute but no changes made\ngit checkout -b feat/new-thing\n\n[DRY RUN] Command would execute but no changes made\ngit push --set-upstream origin feat/new-thing\n\n```\n\nThis way you get a safe, educational view of how the workflow plays out, without changing a thing.\n\n### Wrapping up\n\n`--dry-run` is a small addition, but it captures the essence of what I want `tbdflow` to be: a helpful assistant that removes friction while staying transparent. It‚Äôs there to keep you in flow, but also to show you the ropes so you can deepen your understanding of Git and Trunk-Based Development.\n\nGive it a try, and reveal the magic!\n\n",
      "created_at": "2025-08-23T13:43:38.235213Z",
      "modified_at": "2025-08-23T14:46:25.214257Z"
    },
    {
      "key": "tbdflow-gif-post",
      "title": "tbdflow-gif-post",
      "tags": [],
      changes.txt\"\nEnter\nSleep 1s\n\n# Run the tbdflow commit command\nType 'tbdflow commit -t feat -s auth -m \"add password reset endpoint\"'\nEnter\nSleep 1s\n\n# Answer the DoD checklist\n# Use Space to select, Down to move\nSpace\nSleep 500ms\nDown\nSpace\nSleep 500ms\nDown\nSpace\nSleep 500ms\nDown\nSpace\nSleep 500ms\nDown\nSpace\nSleep 1s\n\n# Show the final result\nType 'tbdflow sync'\nEnter\nSleep 5s\n```\n\nSee the full script at [tbdflow-commit.tape](https://github.com/cladam/tbdflow/blob/main/docs/commit-demo.tape).\n\n3. **Generate the GIF**\n\n    This was the easiest part. With the script written, all I had to do was run:\n\n```bash\nvhs commit-demo.tape\n```\n\n`vhs` then automatically opened a terminal, ran my entire scripted demo, and saved the output as a high-quality GIF.\n\n\n### Conclusion\n\nUsing a tool like `vhs` was a amazing. It turned the whole process into a simple, repeatable engineering task. It allowed me to create the demo I wanted and made the examples much more attractive. \n\nCheck it out:\n\n![A terminal running the command tbdflow](https://raw.githubusercontent.com/cladam/tbdflow/main/docs/commit-demo.gif \"A demo of tbdflow running commit-to-main commands\")\n",
      "created_at": "2025-08-16T18:56:51.664906Z",
      "modified_at": "2025-08-17T08:21:21.367419Z"
    },
    {
      "key": "tbdflow-monorepo",
      "title": "tbdflow-monorepo",
      "tags": [],
      "content": "---\nlayout: post\ntitle: tbdflow ‚ù§Ô∏è monorepo\ntagline: tbdflow is now \"monorepo-aware\"\n---\n\nMonorepos are a powerful strategy for managing code. By keeping all your projects in a single repository, you get a single source of truth, simplified dependency management, and easier cross-team collaboration. As influencial thought-leaders and others in the DevOps space have pointed out, monorepos are a natural fit for Trunk-Based Development (TBD) because they both revolve around a single, shared mainline of code.\n\nBut with great power comes great responsibility. The biggest challenge of a monorepo is the risk of accidental cross-project changes. How do you commit a change to a root-level `README.md` without accidentally staging unrelated work from the `frontend` and `backend` projects?\n\nThis is exactly the kind of workflow problem that a good tool should solve. That's why tbdflow is now \"monorepo-aware.\"\n\n### The Goal: Safe Commits from Anywhere\n\nThe ideal monorepo workflow should be intuitive and safe. A developer should be able to:\n\n1. Make a change within a specific project (e.g. `frontend/`) and have their commit be automatically scoped to just that project.\n2. Make a change to a shared, root-level file (like `CHANGELOG.md`) and commit it without fear of including unrelated work from other projects.\n\n`tbdflow` now supports this out of the box with a simple configuration.\n\n### How It Works: The `monorepo` Config\nTo enable monorepo mode, you first run `tbdflow init` at the root of your repository. This creates a `.tbdflow.yml` file where you can define your project directories.\n\n```yaml\n# in .tbdflow.yml\nmonorepo:\n  enabled: true\n  # A list of all directories that are self-contained projects.\n  # These will be excluded from root-level commits and status checks.\n  project_dirs:\n    - \"frontend\"\n    - \"backend-api\"\n    - \"infra\"\n```\n\nWith this in place, `tbdflow`'s behavior becomes context-aware:\n\n#### Committing from the Root\n\nWhen you run `tbdflow commit` from the root of the repository, the tool is now smart enough to know it should only stage changes to root-level files. It automatically constructs a `git add` command that excludes all the project directories you've defined.\n\nThis gives you a safe, reliable way to manage your shared, repository-level files.\n\n#### Committing from a Project Directory\n\nTo work within a specific project, you first cd into that directory and run `tbdflow init` again. This creates a new, project-specific `.tbdflow.yml` file that tells `tbdflow` to scope its commands.\n\nNow, when you run `tbdflow commit` from within `frontend/`, the tool behaves as you'd expect. It scopes its `git add .` command to only the `frontend/` directory, ensuring your commit is focused and self-contained.\n\nThe `status` and `sync` commands are also monorepo-aware, giving you a clean, relevant view of your working directory by ignoring other projects when you're at the root.\n\n### Conclusion\n\nTrunk-Based Development and monorepos are a powerful combination for high-performing teams. By adding these new monorepo-aware features, `tbdflow` acts as an intelligent guardrail, helping you and your team get all the benefits of this workflow while avoiding its most common pitfalls.\n\n\n",
      "created_at": "2025-08-28T15:07:11.421899Z",
      "modified_at": "2025-08-28T15:07:11.421901Z"
    },
    {
      "key": "tbdflow-plugin-post",
      "title": "tbdflow-plugin-post",
      "tags": [
        "plugin"
      ],
      tbdflow\n\nThe plugin also integrates the other `tbdflow` commands (`branch`, `complete`, `sync`, etc.) into the IDE‚Äôs **Tools** menu. That means you can follow your team‚Äôs workflow without breaking flow by switching to the terminal.\n\n### The friendly assistant, IDE-enabled\n\nThe goal of `tbdflow` has always been to be a \"friendly assistant\" that makes the right way the easy way. This plugin brings that assistant directly into the environment where developers spend most of their time.\n\nIt's available on [JetBrains Marketplace](https://plugins.jetbrains.com/plugin/28339-tbdflow), and in the IDE just search for `tbdflow`. BTW, most of JetBrains products are supported, not just IntelliJ. I personally use it in RustRover.\n\nYou can explore the source code in the tbdflow monorepo at [tbdflow/plugins/intellij](https://github.com/cladam/tbdflow/tree/main/plugins/intellij)\n\n\n",
      "created_at": "2025-08-31T11:46:21.531770Z",
      "modified_at": "2025-09-02T07:33:21.837061Z"
    },
    {
      "key": "tbdflow-readme",
      "title": "tbdflow-readme",
      "tags": [],
      tbdflow.1\n```\n\n",
      "created_at": "2025-08-25T06:57:13.843400Z",
      "modified_at": "2025-08-29T16:39:28.885121Z"
    }
  ]
}
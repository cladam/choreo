{
  "export_date": "2025-09-15T04:54:24.251769Z",
  "note_count": 22,
  "notes": [
    {
      "key": "changelog-blogpost",
      "title": "CHANGELOG.md",
      "tags": [
        "blogpost"
      ],
      "content": "---\nlayout: post\ntitle: CHANGELOG.md\n---\n\nI've seen some teams and projects having really nice CHANGELOG.md and release notes but knowing from experience, writing release notes by hand is a pain. Scrolling through `git log`, guessing which commits count as features or fixes, and hoping you don’t forget something important isn’t exactly fun.\n\nIn DevOps we often talk about removing toil and automating the boring things and I wanted to see if `tbdflow` could help with that. Since the tool already encourages [Conventional Commits](https://www.conventionalcommits.org/), we’ve got a clean, structured Git history ready to be turned into a CHANGELOG. So, I added a new command: **`changelog`**.\n\n\n## Generating a CHANGELOG in one command\n\nThe `changelog` command turns the commit history into a clear, readable, and nice-looking CHANGELOG automatically. I took inspiration of the formatting by `release-please`, and because I have used `tbdflow`to commit changes to `tbdflow` I had the advantage of having a pretty clean commit history.\n\nI categorised the allowed _types_ in sections:\n\n```rust\n/// Returns the section header based on the commit type.\nfn get_section_header(commit_type: &str) -> &'static str {\n    match commit_type {\n        \"feat\" => \"### ✨ Features\",\n        \"fix\" => \"### 🐛 Bug Fixes\",\n        \"perf\" => \"### 🚀 Performance Improvements\",\n        \"refactor\" => \"### 🔨 Code Refactoring\",\n        \"build\" | \"chore\" | \"ci\" | \"docs\" | \"style\" | \"test\" => \"### ⚙️ Maintenance\",\n        _ => \"### Miscellaneous\",\n    }\n}\n```\n\nThen I looped thru my git log, adding a header and links and printing it to `stdout`.\n\n### The changelog command\n\nLet's take a look at the two options we can use. The first one is looking at last release up until HEAD:\n\n```bash\ntbdflow changelog --unreleased\n```\n\nThis will generate a nice CHANGELOG of unreleased changes which could be good to have as `tbdflow sync` only prints `git log --graph --oneline -n 15` (you can see all Git commands `tbdflow` is using by adding `--verbose` before any other command, like `tbdflow --verbose sync`)\n\nAfter a release we can run the `changelog` command with a range, to show all commits that happened within that span.\n\n```bash\ntbdflow changelog --from v0.13.0 --to v0.14.0\n```\n\nIt groups commits by category and outputs something like this:\n\n```markdown\n# [0.13.0](https://github.com/cladam/tbdflow/releases/tag/v0.13.0) (2025-08-20)\n\n### 🔨 Code Refactoring\n- **(commit):** moved commit handler to seperate file to keep main clean-er [`8975588`](https://github.com/cladam/tbdflow/commit/89755887be8322a6cd0739772731432278098a47)\n- updated init command to handle populated remote repo [`87e9e5e`](https://github.com/cladam/tbdflow/commit/87e9e5ee25798f677f552506dfcef4cfa25247df)\n\n### ⚙️ Maintenance\n- **(release):** bump version and publish to GH Releases and crates.io [`428628c`](https://github.com/cladam/tbdflow/commit/428628c394cce08017e6e2a434799f900e8d198a)\n\n```\n\n## Updating CHANGELOG.md\n\nMost projects keep the latest release at the top of the changelog. Prepending text manually can be tricky as `>> append` is the default, but here’s the one-liner I use in tbdflow itself:\n\n```bash\n{ tbdflow changelog --from v0.12.0 --to v0.13.0; echo; cat CHANGELOG.md; } > CHANGELOG.md.tmp && mv CHANGELOG.md.tmp CHANGELOG.md\n```\n\nIt generates the new section, adds a blank line, and then appends the old content—all in one step.\n\n## Wrapping Up\n\nThe new `changelog` command is another step in `tbdflow`'s mission to be a \"friendly assistant\" for your TBD workflow. \nIt takes one more repetitive task off your plate, so you can spend more time writing code.\n\nTake a look at `tbdflow`'s [CHANGELOG](https://github.com/cladam/tbdflow/blob/main/CHANGELOG.md), generated by the `changelog` command 🙂\n\n",
      "created_at": "2025-08-20T22:01:06.094173Z",
      "modified_at": "2025-08-20T22:01:06.094174Z"
    },
    {
      "key": "choreo-reference",
      "title": "choreo-reference",
      "tags": [],
      "content": "# Choreo DSL Reference\n\n**choreo** is an executable Domain-Specific Language (DSL) for writing automated, behaviour-driven tests for command-line applications and system interactions. It uses a structured, human-readable format to define test scenarios that are easy to write, read, and maintain.\n\nThis document serves as the official reference guide for the `.chor` file format and its syntax.\n\n## File Structure: The BDD Hierarchy\n\nA `.chor` file is structured hierarchically to tell a clear story, following the standard BDD pattern of `Feature -> Scenario -> Test`.\n\n```\nfeature \"A high-level description of the capability being tested\"\n\n# ... (settings, vars, actors)\n\nscenario \"A concrete example of the feature's behaviour\" {\n\n    test TestNameOne \"The first step in the scenario\" {  \n        given:  \n            # Pre-conditions and setup actions  \n        when:  \n            # The single action being tested  \n        then:  \n            # The expected outcomes and assertions  \n    }\n\n    test TestNameTwo \"The second step, depending on the first\" {  \n        given:  \n            Test has_succeeded TestNameOne  \n        # ... and so on  \n    }\n\n    after {  \n        # Cleanup actions that run after all tests in this scenario  \n    }  \n}\n```\n\n## Keywords\n\n`choreo` uses a set of keywords to define the structure and logic of a test suite.\n\n#### `feature`\n\nProvides a high-level description of the software capability being tested and groups related scenarios. A `.chor` file should contain exactly one `feature`.\n\n**Example:**\n\n```\nfeature \"User account management via the CLI\"\n```\n\n#### `settings`\n\nA block for configuring the behaviour of the `choreo` test runner for the current file.\n\n**Example:**\n```\nsettings:  \n  timeout_seconds = 60  \n  stop_on_failure = true  \n  shell_path = \"/bin/bash\"  \n  report_path = \"test-results/\"\n```\n\n#### `vars`\n\nA block for defining key-value variables that can be used throughout the test file. This is useful for making tests more readable and maintainable by avoiding \"magic strings.\"\n\n**Example:**\n```\nvars:  \n  FILENAME = \"my_output.txt\"  \n  GREETING = \"Hello, Choreo!\"\n```\n\n#### `env`\n\nDeclares a list of environment variables that the test suite requires. The test runner will read these from the shell environment where `choreo` is executed and make them available for substitution.\n\n**Example:**\n```\nenv: API_TOKEN, GITHUB_USER\n```\n\n#### `actors`\n\nDeclares the different systems or components that the test will interact with. The two currently supported actors are `Terminal` and `FileSystem`.\n\n**Example:**\n```\nactors: Terminal, FileSystem\n```\n\n#### `scenario`\n\nDescribes a single, concrete example of the feature's behaviour. It acts as a container for a sequence of related `test` blocks that form a user story or workflow.\n\n**Example:**\n```\nscenario \"A user can successfully create and then delete a file\" {  \n    # ... test blocks go here ...  \n}\n```\n\n#### `test`\n\nThe core unit of testing in `choreo`. Each `test` block has a unique name (for dependencies) and a human-readable description. It is composed of `given`, `when`, and `then` blocks.\n\n**Example:**\n```\ntest FileIsCreated \"it creates a new file with content\" {  \n    given: # ...  \n    when:  # ...  \n    then:  # ...  \n}\n```\n\n#### `after`\n\nAn optional block inside a `scenario` that contains a list of cleanup actions. These actions are executed after all `test` blocks within that scenario have completed, regardless of whether they passed or failed.\n\n**Example:**\n```\nscenario \"...\" {  \n    # ... tests ...\n\n    after {  \n        FileSystem delete_file \"${FILENAME}\"  \n    }  \n}\n```\n\n## Test Blocks: Given, When, Then\n\nEach `test` block is structured using the standard BDD keywords to create a clear narrative.\n\n#### `given`:\n\nThe `given` block sets up the context for a test. It can contain a mix of **actions** (to set up the environment) and **conditions** (to check pre-requisites, including dependencies on other tests).\n\n**Example:**\n```\ngiven:  \n    # Action: Ensure a clean state  \n    FileSystem delete_file \"data.txt\"  \n    # Condition: This test can only run after the setup test has passed  \n    Test has_succeeded InitialSetup\n```\n\n#### `when`:\n\nThe `when` block contains the single, specific action that is being tested. A `when` block should contain only actions, not conditions.\n\n**Example:**\n```\nwhen:  \n    Terminal runs \"data-processor --input data.txt\"\n```\n\n#### `then`:\n\nThe `then` block contains the assertions that verify the outcome of the `when` action. A `then` block should contain only conditions. The test passes if all `then` conditions are met.\n\n**Example:**\n```\nthen:  \n    Terminal last_command succeeded  \n    FileSystem file_exists \"output.txt\"\n```\n\n## Vocabulary: Actions & Conditions\n\nThis is the reference for all available commands that can be used within the `test` blocks.\n\n### Wait Conditions\n\n| Syntax | Description |\n| :---- | :---- |\n| `wait \\>= 1.5s` | Passes if the test has been running for at least 1.5 seconds. |\n| `wait \\<= 100ms` | Passes if the test has been running for no more than 100 milliseconds. |\n\n### State Conditions\n\n| Syntax                        | Description |\n|:------------------------------| :---- |\n| `Test has_succeeded <TestName>` | Passes if the test with the given name has already passed. This is the primary mechanism for creating dependencies. |\n\n### Terminal Commands\n\n#### Actions\n\n| Syntax | Description                                                                             |\n| :---- |:----------------------------------------------------------------------------------------|\n| `Terminal runs \"...\"` | Executes a shell command non-interactively. The command and a newline are sent at once. |\n| `Terminal types \"...\"` | Simulates a user typing a string into the terminal.                                     |\n| `Terminal presses \"Enter\"` | Simulates a user pressing the Enter key.                                                |\n\n#### Conditions\n\n| Syntax                                     | Description                                                                        |\n|:-------------------------------------------|:-----------------------------------------------------------------------------------|\n| `Terminal last_command succeeded`          | Passes if the last `Terminal runs` command exited with code 0.                     |\n| `Terminal last_command failed`             | Passes if the last `Terminal runs` command exited with a non-zero code.            |\n| `Terminal last_command exit_code_is <num>` | Passes if the last `Terminal runs` command exited with the specified code.           |\n| `Terminal output_contains \"...\"`           | Passes if the combined stdout/stderr stream from the PTY contains the substring.   |\n| `Terminal stdout_is_empty`                 | Passes if the stdout from the last `Terminal runs` command was empty.                |\n| `Terminal stderr_contains \"...\"`           | Passes if the stderr from the last `Terminal runs` command contains the substring.   |\n| `Terminal output_starts_with \"...\"`        | Passes if the trimmed stdout of the last `runs` command starts with the string.      |\n| `Terminal output_ends_with \"...\"`          | Passes if the trimmed stdout of the last `runs` command ends with the string.        |\n| `Terminal output_equals \"...\"`             | Passes if the trimmed stdout of the last `runs` command is an exact match.           |\n| `Terminal output_matches \"...\"`            | Passes if the combined stdout/stderr stream from the PTY matches the regex.        |\n\n### FileSystem Commands\n\n#### Actions\n\n| Syntax                                          | Description |\n|:------------------------------------------------| :---- |\n| `FileSystem create_dir \"...\"`                     | Creates a directory, including any necessary parent directories. |\n| `FileSystem create_file \"...\"`                    | Creates an empty file. |\n| `FileSystem create_file \"...\" with_content \"...\"` | Creates a file and writes the specified content to it. |\n| `FileSystem delete_dir \"...\"`                     | Deletes a directory and all its contents. |\n| `FileSystem delete_file \"...\"`                    | Deletes a file. |\n\n#### Conditions\n\n| Syntax                                 | Description |\n|:---------------------------------------| :---- |\n| `FileSystem dir_exists \"...\"`          | Passes if a directory exists at the specified path. |\n| `FileSystem file_exists \"...\"`         | Passes if a file exists at the specified path. |\n| `FileSystem file_does_not_exist \"...\"`  | Passes if nothing exists at the specified path. |\n| `FileSystem file_contains \"...\" \"...\"`  | Passes if the file at the first path contains the second string. |\n\n## Variables\n\n`choreo` supports both environment variables and file-defined variables for making tests dynamic.\n\n### Substitution\n\nTo use a variable, use the `${VAR_NAME}` syntax inside any string literal. The test runner will replace this placeholder with the variable's value before executing the step.\n\n**Example:**\n```\nvars:  \n  FILENAME = \"output.log\"  \nwhen:  \n  Terminal runs \"echo 'hello' > ${FILENAME}\"  \n```\n\n",
      "created_at": "2025-09-12T12:03:44.571663Z",
      "modified_at": "2025-09-12T12:03:44.571664Z"
    },
    {
      "key": "choreo-test",
      "title": "choreo-test",
      "tags": [],
      "content": "# My quick medi note",
      "created_at": "2025-09-15T04:54:24.012184Z",
      "modified_at": "2025-09-15T04:54:24.012185Z"
    },
    {
      "key": "cladam_github_io_readme",
      "title": "cladam_github_io_readme",
      "tags": [],
      "content": "## Personal Site & Blog - `cladam.github.io`\n\nThis repository contains the source code for my personal website and blog, which is built with Jekyll and hosted on GitHub Pages. You can view the live site at [cladam.github.io](https://cladam.github.io).\n\n## About This Project\n\nEvery developer needs a home on the web; a space to share ideas, document experiments, and showcase what they’re building. This site is my space. I wanted something clean, content-first, and flexible enough to host both long-form writing and structured documentation for my open-source projects.\n\n## The Technology\n\nThe site is built using Jekyll, a static site generator. The theme is a custom one, built from scratch with a clean, content-focused design inspired by the `Lanyon` theme. It features a persistent sidebar for easy navigation and a simple, readable layout for both blog posts and project documentation.\n\n## Still Evolving\n\nThis site is a work in progress, and that’s the point. I built it by making small, testable changes and letting each improvement inform the next. That same philosophy, _make it work, make it better_, is what shapes the tools I build and the workflows I advocate for.\n",
      "created_at": "2025-08-14T12:41:54.729134Z",
      "modified_at": "2025-08-14T12:41:54.729137Z"
    },
    {
      "key": "jb-marketplace-token",
      "title": "jb-marketplace-token",
      "tags": [],
      "content": "perm-Y2xhZXMuYWRhbXNzb24=.OTItMTMzMTQ=.sAjzENfqrMjQrJEqJhgzwbiIdUGsvT",
      "created_at": "2025-08-31T08:49:16.318768Z",
      "modified_at": "2025-08-31T08:49:16.318768Z"
    },
    {
      "key": "linkedin-tbdflow",
      "title": "post",
      "tags": [],
      "content": "I think dry-runs are great, (\"torrsimma\" in Swedish.)\n\nEspecially in our field, it's very useful to see what will be executed before you run a command.\n\nSure, we can look at the source and try to deduce the flow, but better yet, why not show the user what will actually happen when they press [Enter]?\n\nThat's why I added a --dry-run flag to tbdflow, with it you can see what Git commands it would run, without making any changes.\n\nIt’s both a safety net and a learning tool. I wrote a short post about how it works and why I think it matters:\n🔗 https://cladam.github.io/2025/08/23/dry-run/\n\n#tbdflow #trunkbaseddevelopment #git #cli #developerexperience\n\n\n---\n\nI'm having fun developing tbdflow using Rust, it's pretty easy to build robust CLI tools using clap.\n\ntbdflow is a command-line tool designed to streamline and safeguard your Git workflow for Trunk-Based Development.\n\nI built it to help teams adopt TBD in an easier way.\n\nCheck it out at https://lnkd.in/dvagsyPY\n\n---\n\nHow do you showcase a CLI tool in a README? Static code blocks are fine for reference, but they don't show the tool in action.\n\nI wanted to bring my examples for tbdflow to life, so I created an animated GIF to demonstrate its core workflows. \n\nI wrote a short blog post about how I did it, the tool I used, and how you can create the same kind of demos for your own projects:\n 🔗 https://lnkd.in/d9KZjr2P\n\nhashtag#tbdflow hashtag#cli hashtag#documentation hashtag#developerexperience\n\n---\n\nThanks for all the feedback and interest in tbdflow!\nIt’s been great to see the project pass 2,000+ downloads on crates-io, and I’m excited to keep improving it with your input.\n\nI’ve been working on making it an even better assistant for Trunk-Based Development workflows. The latest version is now live, with a few key updates:\n\n🔹 Stay in sync\nA new sync command gives you a quick overview of your repo. Pulling the latest changes, showing recent history, and checking your local status in one go.\n\n🔹 Keep branches fresh\nsync now also warns you about stale branches that haven’t been updated in over a day, helping you stick to TBD’s “short-lived branches” principle.\n\n🔹 Easy to get started\nA new and improved init command has been added. It sets up your repo with sensible defaults, creating .dod.yml and .tbdflow.yml if they don’t exist, and even initialising the Git repo for you if needed.\n\n🔹 Improved docs and visibility\nI’ve launched a GitHub Page to provide clearer, more accessible documentation and highlight the project’s goals.\n\n📄 Check it out here: https://lnkd.in/d3GMsTj7\n🔗 Original post: https://lnkd.in/dDB3hQfB \n\nhashtag#git hashtag#cli hashtag#rust hashtag#tbd hashtag#continuousdelivery hashtag#opensource\n\n---\n\nTrunk-Based Development (TBD) is one of the best ways to improve software delivery performance.\nIt supports fast feedback, cleaner integration, and better collaboration. It’s also the foundation for Continuous Integration and Continuous Delivery.\n\nTBD promotes committing to trunk (main) daily, ideally multiple times a day. But adopting this workflow isn’t always easy. Remembering the right Git commands, formatting commits, branch cleanup and pushing safely can slow you down. It’s easy to lose momentum when the workflow feels clunky.\n\nTo make the right way the easy way, I’ve been building a small command-line tool in my spare time: tbdflow. \n\nIt’s a simple wrapper around Git that:\n✅ Codifies a safe, opinionated TBD workflow\n✅ Encourages daily commits to main\n✅ Reduces errors and cognitive load\n✅ Supports short-lived branches when you need them\n\nI originally started with a few local bash aliases to handle git pull-commit-push, but wanted something more robust and shareable.\n\nSo if you’re practising TBD (or curious to try it), check it out:\n🔗 github.com/cladam/tbdflow\n\nFeedback and contributions welcome!\n\nhashtag#devops hashtag#trunkbasedevelopment hashtag#ContinuousDelivery hashtag#devex hashtag#opensource\n\n",
      "created_at": "2025-08-23T14:11:31.038099Z",
      "modified_at": "2025-08-23T15:08:56.142391Z"
    },
    {
      "key": "matteo",
      "title": "matteo",
      "tags": [],
      "content": "# Matteo is awesome\n",
      "created_at": "2025-09-08T12:34:23.601180Z",
      "modified_at": "2025-09-08T12:34:23.601182Z"
    },
    {
      "key": "medi",
      "title": "medi",
      "tags": [
        "medi"
      ],
      "content": "medi is a fast, editor-centric, command-line notes manager",
      "created_at": "2025-09-01T22:40:01.097585Z",
      "modified_at": "2025-09-01T22:40:01.097585Z"
    },
    {
      "key": "medi-blogpost",
      "title": "medi-blogpost",
      "tags": [],
      "content": "---\nlayout: post\ntitle: Why did I build medi?\n---\n\n### Where are my files?\n\nI have a bunch of markdown files scattered across my computer, in different repos and folder, and other random temporary spots. It's hard to keep track of them all. It was a frantic dance of `grep`, `find`, and `ls`. It felt like I was fighting the filesystem, `Commander One` helped to a degree but not quite.\n\nI started to think about abstracting away the filesystem and have a central place for my files, like in a lightweight database I could access instantly from anywhere in my terminal.\n\nI had so much fun building [tbdflow](https://cladam.github.io/projects/tbdflow) so I decided to build `medi`.\n\n`medi` is a fast, editor-centric, commandline notes manager I wrote in Rust. It’s my solution to abstracting away the filesystem and creating a focused, high-speed workflow for writing.\n\n### A workflow, not just a folder\n\nThe core idea behind `medi` is to stop thinking about files and start thinking about content. I designed it around a few key principles:\n\n  * **CLI-first**: All interaction is through the terminal. It’s fast and scriptable, as an old Linux user I like pipes...\n  * **Editor-centric**: `medi` isn't an editor but it will get you into _your_ favorite editor (`$EDITOR`) with the right content. I use Neovim myself: `export EDITOR=nvim`\n  * **Local & private**: Your data is yours. It lives on your machine, no cloud component and no spyware, fully OSS.\n\n### Speed is a feature\n\nThe biggest win comes from using `sled`, an embedded database written in pure Rust. Instead of scanning a directory, `medi` performs a direct key lookup.\n\n```bash\n# This is instantaneous, even with thousands of notes.\nmedi get \"my-old-project-idea\"\n```\n\nThis makes finding and reading notes feel very snappy, which is what you want from a tool you use every day.\n\n### Flexible by design\n\nA good CLI tool should adapt to your needs. `medi new` supports three distinct workflows for creating notes, which has been a game-changer for me.\n\n1.  **Interactively (for long-form writing):**\n\n    ```bash\n    medi new \"my-next-blog-post\"\n    # Opens Neovim in a fresh .md buffer\n    ```\n\n2.  **With a flag (for quick thoughts):**\n\n    ```bash\n    medi new quick-reminder -m \"Don't forget to buy milk\"\n    ```\n\n3.  **From a pipe (for scripting):**\n\n    ```bash\n    git log -1 --pretty=format:\"%s\" | medi new latest-commit-message\n    ```\n\n### Version control\n\nOf course, plain text files have one huge advantage: **Git**. I didn’t want to lose the ability to version control my writing.\n\nThat’s what the `import` and `export` commands are for. They act as a bridge between the fast `sled` database and the version-controllable world of the filesystem. My workflow is simple: I write and edit in `medi` all week, and then run `medi export ./notes-repo` and commit the changes. It's the speed of a database with the safety of Git.\n\n### Check it out\n\nBuilding `medi` has been a great learning experience in Rust, and it has genuinely improved my daily workflow. If you’re a command-line enthusiast who deals with a lot of Markdown, I’d love for you to give it a try.\n\nYou can find the source code on [**GitHub**](https://github.com/cladam/medi) or install it directly with Cargo:\n\n```bash\ncargo install medi\n```\n\nThe project is still young, and there are plenty of ideas on the roadmap, like adding task management features and full-text search. Check out the README and let me know what you think!\n\n---\n\n### Real-world usage\n\nThis blog entry was written using `medi`,\n\n```bash\nmedi new medi-blogpost\n# writing and then saving for a break, ZZ\nmedi edit medi-blogpost\n# save and close ZZ, or :wq if you like that better\nmedi get medi-blogpost > _posts/2025-08-12-why-medi.md\n# Commit using tbdflow\ntbdflow commit -t feat -s blog -m \"add blog entry about medi\"\n```\n\n",
      "created_at": "2025-08-14T12:41:54.736451Z",
      "modified_at": "2025-08-14T12:41:54.736451Z"
    },
    {
      "key": "medi-perf-test",
      "title": "medi-perf-test",
      "tags": [
        "blog",
        "medi"
      ],
      "content": "---\nlayout: post\ntitle: Blazing fast search\n---\n\nWhen I started building `medi`, my command-line notes manager, the goal was a fast, local-first workflow. But how fast is _fast_? Could it stay fast at scale? With a database of thousands of notes, would search grind to a halt?\n\nA user on Reddit asked the same question, so I decided to find out. At first, I hacked together a quick `bash` script, but I wanted something more solid in the test suite. The results were better than I expected.\n\n### The test\n\nI wrote a simple performance test that does three things:\n\n1. **Generate Data**: Create 1,000 notes, each \\~50KB of random text (\\~50MB total).\n2. **Build Index**: Run `medi reindex` to build a full-text search index from scratch.\n3. **Run Search**: Time a “cold” search for a single word, including application startup.\n\n### The results\n\nThe numbers speak for themselves:\n\n* **Reindexing 1,000 notes (50MB of text):** `2.7 seconds`\n* **Searching the entire database:** `106 milliseconds`\n\n\n### Analysis\n\nRebuilding a search index for 50MB of text in under three seconds is a great sign, even if the index gets corrupted, it can be rebuilt in no time.\n\nThe real win is search speed. That 106ms includes everything: starting the binary, loading the index from disk, parsing the query, running the search, and printing the result. The actual search is probably in the single-digit milliseconds. From the user’s perspective it's instant.\n\nThis test also validates the architecture choice: `sled` for storage + `tantivy` for search is reliable and **fast**. It gives me confidence that `medi` will stay responsive with 10,000 notes as it is with just 10.\n\nIf you’re building a Rust app that needs local search, I can highly recommend [`tantivy`](https://github.com/quickwit-oss/tantivy). You can also check out `medi` and its implementation on [my GitHub](https://github.com/cladam/medi).\n\n",
      "created_at": "2025-09-06T19:45:01.816820Z",
      "modified_at": "2025-09-06T19:45:01.816821Z"
    },
    {
      "key": "medi-readme",
      "title": "medi-readme",
      "tags": [
        "medi",
        "README"
      ],
      "content": "<div align=\"center\">\n\n<p align=\"center\">\n  <img src=\"assets/medi-logo.png\" alt=\"medi logo\" width=\"200\"/>\n</p>\n\n<p align=\"center\">\n  <b>⚡ A speedy CLI Markdown Manager ⚡</b><br/>\n  Lightweight • Local-first • Editor-friendly\n</p>\n\n[![Crates.io](https://img.shields.io/crates/v/medi.svg)](https://crates.io/crates/medi)\n[![Downloads](https://img.shields.io/crates/d/medi.svg)](https://crates.io/crates/medi)\n\n</div>\n\n\n## About\n\n**[[medi]] is a fast, editor-centric, command-line notes manager.**\n\n`medi` is a simple and powerful tool for creating and managing your notes, articles, and documentation directly from the terminal. It's built for developers, writers, and anyone who loves the speed and focus of a command-line workflow.\n\n![A terminal running medi commands](docs/medi.gif \"A demo of medi\")\n\n## Philosophy\n\n`medi` is built on a few guiding principles:\n\n- **CLI-first**: Everything is done through the terminal. No GUIs or TUIs, no distractions.\n- **Editor-centric**: Your text editor (`$EDITOR`) is where you write. `medi` gets you there quickly and saves your work securely.\n- **Local & private**: All content is stored on your local machine in a high-performance embedded database. No cloud services, no network access.\n- **Zero-config start**: Install it and start writing immediately.\n\n## Features ✨\n\n- **Create & Manage Notes**: Quickly create new notes using a simple command (`medi new <note-key>`). You can add content directly with a flag, pipe it from other commands, or open your favorite text editor for more detailed entries.\n- **Powerful Organisation**: Keep your notes tidy with tags. Add multiple tags when creating a note (`--tag`) and easily add or remove them later (`medi edit --add-tag ...`).\n- **Integrated Task Management**: Turn your notes into actionable to-do lists. Add tasks to any note (`medi task add ...`), list all your pending items, mark them as complete (`medi task done ...`), and set priorities to focus on what's important.\n- **Full-text Search**: Instantly find what you're looking for with a powerful search command (`medi search <term>`) that scans the content of all your notes.\n- **Import & Export**: `medi` is not a data silo. You can easily import entire directories of Markdown files to get started, and export all your notes back to Markdown or JSON at any time.\n- **List & Review**: Get a clean, sorted list of all your notes (`medi list`) or view the content of any specific note (`medi get <note-key>`).\n- **Finding Connections & Notes**: Use `[[wiki-like]]` syntax to link back to a note, and use a fuzzy finder to quickly find and edit a note by its key.\n- **Colourful & Clear Output**: Uses coloured output to clearly distinguish between success messages, information, warnings, and errors.\n\n## How It Works, DB as Source-of-Truth\n\n`medi` uses a database-first approach. All your notes are stored in a `sled` key-value database, making access fast and reliable. This database is the single source of truth.\n\nTo version control your work with Git, `medi` provides a simple and deliberate workflow:\n\n- **Write**: Use `medi new` and `medi edit` to manage your notes.\n- **Export**: Run `medi export ./my-notes` to write all your notes to a local directory as `.md` files.\n- **Commit**: Use Git to commit the exported directory, giving you a complete, version-controlled snapshot of your work.\n\n### Installation\n\nYou need [Rust and Cargo](https://www.rust-lang.org/tools/install) installed.\n\n#### Installing from crates.io\n\nThe easiest way to install `medi` is to download it from [crates.io](https://crates.io/crates/medi). You can do it using the following command:\n\n```bash\ncargo install medi\n```\n\nIf you want to update `medi` to the latest version, execute the following command:\n\n```bash\nmedi update\n```\n\n#### Building from source\n\nAlternatively you can build `medi` from source using Cargo:\n\n```bash\ngit clone https://github.com/cladam/medi.git\ncd medi\nsudo cargo install --path . --root /usr/local\n```\n\n## Configuration\n\nOn the first run, `medi` will automatically create a default configuration file at the standard location for your operating system:\n\n  * **macOS**: `~/Library/Application Support/medi/config.toml`\n  * **Linux**: `~/.config/medi/config.toml`\n  * **Windows**: `C:\\Users\\<user>\\AppData\\Roaming\\medi\\config.toml`\n\nYou can edit this file to customize `medi`'s behaviour.\n\n### Example `config.toml`\n\n```toml\n# Path to the database file.\n# You can change this to store your notes in a different location,\n# for example, inside a cloud-synced folder like Dropbox.\ndb_path = \"/Users/cladam/Library/Application Support/medi/medi_db\"\n\n# Default directory for the `medi export` command.\n# If this is set, you can run `medi export` without specifying a path.\n# Leave it as an empty string (\"\") if you don't want a default.\ndefault_export_dir = \"/Users/cladam/Documents/medi_backups\"\n```\n\n## Usage\n\n### Creating and Editing Notes\n\n* **Create a new note**\n\n  `medi` provides three ways to create a new note:\n\n  1.  **Interactively (default)**: Opens your default editor for long-form content.\n      ```bash\n      medi new \"my-long-article\"\n      # With tags: Add tags to your note for better organisation.\n      medi new \"my-long-article\" --tag tag1 --tag tag2\n      # With a title: Specify a title for your note.\n      medi new \"my-long-article\" --title \"My Long Article\"\n      ```\n\n  2.  **With a direct message**: Perfect for quick, one-line notes.\n      ```bash\n      medi new quick-idea -m \"Remember to buy milk\"\n      ```\n\n  3.  **From a pipe**: Use the output of other commands as your note content.\n      ```bash\n      echo \"This is a note from a pipe\" | medi new piped-note\n      ```\n\n* **Edit an existing note**\n  ```bash\n  medi edit \"my-long-article\"\n  \n  # Add tags to a note\n  medi edit \"my-long-article\" --add-tag tag1 --add-tag tag2\n  \n  # Remove tags from a note\n  medi edit \"my-long-article\" --rm-tag tag1 --rm-tag tag2\n  ```\n\n### Using Templates 📝\n\n`medi` can create new notes from predefined templates to speed up your workflow. On its first run, `medi` creates an example `meeting.md` template in the configuration directory.\n\n- **Location of templates:**\n\n    * **macOS**: `~/Library/Application Support/medi/templates/`\n    * **Linux**: `~/.config/medi/templates/`\n    * **Windows**: `%APPDATA%\\medi\\templates\\`\n\n- **Create a note from a template:**\n\n  ```bash\n  medi new my-project-meeting --template meeting\n  ```\n\n- **Create your own templates:**\n  Simply add any `.md` file to your templates directory. If you create `blog.md`, you can use it with `medi new ... --template blog`.\n\n\n### Finding, Viewing & Listing Notes\n\n⚠️ This feature is not supported on Windows.\n\n  - **Interactively find a note**\n    Open a fuzzy finder to quickly search for and edit a note by its key.\n\n    ```bash\n    medi find\n    ```\n\n    This will open an interactive TUI to help you find the note you want to edit.\n\n\n  - **Get a note's content**\n    Prints the note directly to the console. This is perfect for piping to other tools.\n\n    ```bash\n    medi get \"my-first-article\"\n\n    # Pipe to a Markdown renderer like mdcat\n    medi get \"my-first-article\" | mdcat\n\n    # Get a note in Json format\n    medi get \"my-first-article\" --json\n\n    # Get one or several notes via a tag\n    medi get --tag my-tag\n    ```\n\n  - **List all notes**\n    The `list` command provides a rich overview of your notes, including their keys and tags.\n\n    ```bash\n    medi list\n    ```\n\n    *Output:*\n\n    ```\n    - cladam_github_io_readme [#blog #project]\n    - medi-blogpost [#rust]\n    ```\n\n  - **Sort your notes**\n    You can sort the list by creation or last modification date using the `--sort-by` flag. The default is to sort alphabetically by key.\n\n    ```bash\n    # Sort by the most recently modified notes\n    medi list --sort-by modified\n\n    # Sort by when the notes were created\n    medi list --sort-by created\n    ```\n\n### Searching & Indexing\n\n`medi` includes a full-text search engine (`tantivy`) that lets you find notes by their content, title, or tags.\n\n**Search for a note**\n```bash\n# Find all notes containing the word \"rust\"\nmedi search rust\n\n# Search for a phrase\nmedi search \"database design\"\n```\n\n_Output_:\n\n```\nSearch Results:\n- medi-blogpost\n- rust-cli-ideas\n```\n\n**Rebuild the search index**\n\nIf your search index ever gets out of sync or you're setting up `medi` for the first time with an existing database, you can rebuild the entire index.\n\n```bash\nmedi reindex\n```\n\n### Deleting a Note\n\n- **Delete a note**\n  You will be prompted for confirmation.\n\n  ```bash\n  medi delete \"my-first-article\"\n\n  # Skip the confirmation prompt\n  medi delete \"my-first-article\" --force\n  ```\n\n### Versioning with Export/Import\n\n- **Export all notes to a directory**\n  Creates a version-controllable snapshot of your database.\n\n  ```bash\n  medi export ./my_notes_backup\n  cd my_notes_backup\n  tbdflow init\n  ```\n- **Export all notes to a Json document**\n\n  ```bash\n  medi export medi-export --format json\n  ```\n- **Export notes via a tag**\n\n  ```bash\n  medi export medi-export --tag my-tag\n  ```\n\n- **Import notes from a directory**\n  Restores notes from a directory of `.md` files.\n\n  ```bash\n  # By default, skips any notes that already exist\n  medi import --dir /path/to/notes\n\n  # Import a single\n  medi import --file /path/to/note.md --key my-note\n\n  # Overwrite existing notes with the imported versions\n  medi import --file /path/to/note.md --key my-note --overwrite\n  ```\n\n### Task Management\n\n`medi` includes a simple task manager to help you turn notes into actionable to-do lists.\n\n  - **Add a task to a note**\n\n    ```bash\n    medi task add my-blog-post \"Finish the conclusion section\"\n    ```\n\n  - **List all tasks**\n    \n    The list is sorted by priority and status.\n\n    ```bash\n    medi task list\n    ```\n\n    _Output:_\n\n    ```\n    Tasks:\n    [42] [Prio] ⭐ : Review final draft (for note 'medi-readme')\n    [43] [Open] : Add usage examples (for note 'medi-readme')\n    [44] [Done] : Write introduction (for note 'my-blog-post')\n    ```\n\n  - **Prioritise a task**\n\n    ```bash\n    medi task prio 43\n    ```\n\n  - **Complete a task**\n\n    ```bash\n    medi task done 43\n    ```\n\n  - **Delete a task**\n\n    ```bash\n    medi task delete 43\n    ```\n\n  - **Clear all tasks**\n    \n    This is a destructive action\n\n    ```bash\n    medi task reset\n    ```\n\n\n### Checking Status\n\nThe `status` command provides a high-level overview of your database or detailed statistics for a single note.\n\n  - **Get a global overview:**\n\n    ```bash\n    medi status\n    ```\n\n    _Output:_\n\n    ```\n    medi status\n      Notes: 42\n      Tasks: 8 open (3 priority)\n    ```\n\n  - **Get stats for a specific note:**\n\n    ```bash\n    medi status medi-blogpost\n    ```\n\n    _Output:_\n\n    ```\n    medi-blogpost\n      Key: medi-blogpost\n      Tags: rust, cli\n      Words: 584\n      Reading Time: ~3 minute(s)\n      Created: Mon, 12 Sep 2025 10:30:00 +0200\n      Modified: Tue, 13 Sep 2025 15:00:00 +0200\n    ```\n\n### Discover Connections\n\n  - **Find backlinks for a note**\n    Discover all the notes that link to a specific topic using `[[wiki-link]]` syntax.\n\n    ```bash\n    medi backlinks rust\n    ```\n\n    _Output:_\n\n    ```\n    Found 1 backlinks for 'rust':\n    - medi-project\n    ```\n\n### Shell Completion\n\nTo make `medi` even faster to use, you can enable shell completion. Add one of the following lines to your shell's configuration file.\n\nFor Zsh (`~/.zshrc`):\n\n```bash\neval \"$(medi generate-completion zsh)\"\n```\n\nFor Bash (`~/.bashrc`):\n\n```bash\neval \"$(medi generate-completion bash)\"\n```\n\nFor Fish (`~/.config/fish/config.fish`):\n\n```bash\nmedi generate-completion fish | source\n```\n\n## Project Roadmap 🗺️\n\nThis section tracks the implementation status of `medi`'s features. Contributions are welcome!\n\n- [x] All core commands (new, get, list, edit, delete, import, export).\n- [x] Configuration file for settings (e.g. database path).\n- [x] Support for note metadata (tags, creation dates).\n- [x] `export` notes by tag.\n- [x] Full-text search over note content.\n- [x] Implement a `task` command for tracking the status of notes.\n- [x] Implement a simple status command\n- [x] Add a Fuzzy Finder for notes\n- [x] Add templates for different documents\n- [x] Wiki-Style Linking\n- [ ] ...\n\n",
      "created_at": "2025-08-14T12:41:54.752095Z",
      "modified_at": "2025-09-06T12:41:43.189635Z"
    },
    {
      "key": "meeting-with-rob",
      "title": "meeting-with-rob",
      "tags": [],
      "content": "# Meeting: {{ MEETING TITLE }}\n\n**Date:** {{ YYYY-MM-DD }}\n**Location:**\n**Facilitator:**\n**Notetaker:**\n\n ---\n\n## Attendees\n\n-\n\n---\n\n## Agenda\n\n1.\n2.\n\n---\n\n## Decisions Made\n\n-\n\n---\n\n## Action Items\n\n| Task | Owner | Due Date |\n| ---- | ----- | -------- |\n|      |       |          |\n|      |       |          |\n\n---\n\n## Additional Notes\n\n-",
      "created_at": "2025-08-26T21:55:28.692855Z",
      "modified_at": "2025-08-26T21:55:28.692857Z"
    },
    {
      "key": "milk",
      "title": "milk",
      "tags": [],
      "content": "buy milk",
      "created_at": "2025-09-08T12:34:56.611963Z",
      "modified_at": "2025-09-08T12:34:56.611963Z"
    },
    {
      "key": "project-tbdflow",
      "title": "project-tbdflow",
      "tags": [],
      "content": "---\nlayout: project\ntitle: \"tbdflow\"\ntagline: \"Keep your code flowing\"\n---\n\n<p align=\"center\">\n  <img src=\"/assets/images/tbdflow-logo.png\" alt=\"tbdflow logo\" width=\"200\"/>\n</p>\n\n## Overview\n\n`tbdflow` is a lightweight wrapper around Git that codifies an opinionated TBD workflow. It automates common tasks, encourages best practices like Conventional Commits, and helps maintain a clean and stable `main` branch.\n\n## Philosophy\n\nThis tool is built around a specific philosophy of Trunk-Based Development:\n\n* **Main is the default.** The `commit` command is your everyday go-to. It automates pulling the latest changes, committing, and pushing directly to `main`, promoting small, frequent integrations.\n* **Branches are the exception.** While branches are supported, they’re treated as short-lived exceptions and not the norm.\n* **Cleanup is automatic.** The complete command enforces branch short-livedness by merging and automatically tagging (release/hotfix) and deleting completed branches, helping keep your repo tidy.\n* **Conventional Commits encouraged.** Commit messages follow [Conventional Commits](https://www.conventionalcommits.org/) for clarity and consistency.\n\n### Why not just use Git?\n\nThis CLI isn’t a replacement for Git. You’ll still reach for raw `git` when doing advanced work like rebasing, cherry-picking, or running `git bisect`.\n\nThis tool is as a **workflow assistant**, `tbdflow` encapsulates a repeatable, opinionated process to support your day-to-day development.\n\nIt offers three main benefits:\n\n1. **Consistency across the team**\n   Everyone follows the same steps for common tasks. Commits, branches, and releases are handled the same way every time, keeping your Git history clean and predictable.\n\n2. **Less to remember**\n   No need to recall the exact flags or sequences (like `pull --rebase`, `merge --no-ff`, or commit message formats). The CLI handles that, so you can stay focused on writing code.\n\n3. **It supports \"the TBD way\"**\n   This tool makes the preferred approach easy by providing a smooth, safe, and efficient path for 80% of everyday tasks. For the other 20%, you can always use Git directly.\n\n### Installation\n\nYou need [Rust and Cargo](https://www.rust-lang.org/tools/install) installed.\n\n#### Installing from crates.io\n\nThe easiest way to install `tbdflow` is to download it from [crates.io](https://crates.io/crates/tbdflow). You can do it using the following command:\n\n```bash\ncargo install tbdflow\n```\n\nIf you want to update `tbdflow` to the latest version, execute the following command:\n\n```bash\ntbdflow update\n```\n\n### Configuration\n`tbdflow` is configurable via two optional files in the root of your repository. To get started quickly, run `tbdflow init` to generate default versions of these files.\n\n`.tbdflow.yml`\nThis file controls the core workflow of the tool. You can customise:\n- The name of your main branch (e.g. main, trunk).\n- Allowed branch types and their prefixes (e.g feat/, chore/)\n- A strategy for handling issue references (\"branch-name\" or \"commit-scope\")\n- The threshold for stale branch warnings.\n- Automatic tagging formats.\n- Commit message linting rules.\n\n`.dod.yml`\nThis file controls the interactive Definition of Done checklist for the commit command. \n\n### Features\n\n#### The Definition of Done (DoD) Check\nTo move beyond just automating process, `tbdflow` integrates an optional pre-commit quality check. If a `.dod.yml` file is present in your repository, the commit command will present an interactive checklist to ensure your work meets the team's agreed-upon standards.\n\n**Example** `.dod.yml`:\n\n```yaml\n# --- Interactive Checklist ---\nchecklist:\n  - \"Code is clean, readable, and adheres to team coding standards.\"\n  - \"All relevant automated tests (unit, integration) pass successfully.\"\n  - \"New features or bug fixes are covered by appropriate new tests.\"\n  - \"Security implications of this change have been considered.\"\n  - \"Relevant documentation (code comments, READMEs, etc.) is updated.\"⏎\n```\n\nIf you try to proceed without checking all items, the tool will offer to add a TODO list to your commit message footer, ensuring the incomplete work is tracked directly in your Git history.\n\n#### Commit Message Linting\n\nIf a `.tbdflow.yml` file is present and contains a lint section, the commit command will automatically validate your commit message against the configured rules before the DoD check. This provides immediate feedback on stylistic and structural conventions.\n\n**Default linting rules:**\n\n```yaml\nlint:\n  conventional_commit_type:\n    enabled: true\n    allowed_types:\n    - build\n    - chore\n    - ci\n    - docs\n    - feat\n    - fix\n    - perf\n    - refactor\n    - revert\n    - style\n    - test\n  issue_key_missing:\n    enabled: false\n    pattern: ^[A-Z]+-\\d+$\n  scope:\n    enabled: true\n    enforce_lowercase: true\n  subject_line_rules:\n    max_length: 72\n    enforce_lowercase: true\n    no_period: true\n  body_line_rules:\n    max_line_length: 80\n    leading_blank: true\n```\n\n### Examples of how to use tbdflow\n\n#### Initialise\n\nSet up a new local repo\n\n```bash\n# Create a new local repo\nmkdir tbd && cd tbd\ntbdflow init\n```\n\n#### Using tbdflow \n\n*Default flow:*\n\n```bash\n# A new feature\ntbdflow commit -t feat -s auth -m \"add password reset endpoint\"\n\n# A bug fix with a breaking change\ntbdflow commit -t fix -m \"correct user permission logic\" -b\ntbdflow commit -t refactor -m \"rename internal API\" --breaking --breaking-description \"The `getUser` function has been renamed to `fetchUser`.\"\n\n# A bug fix with a new tag\ntbdflow commit -t fix -m \"correct user permission logic\" --tag \"v1.1.1\"\n\n# Reference an issue\ntbdflow commit -t feat -m \"add feature x as part of bigger thing\" --issue \"ABC-123\"\n```\n\n*Exceptions a.k.a. branches*\n\n```bash\n# Create a feature branch\ntbdflow branch --type feat --name \"user-profile-page\"\n\n# Create a release branch\ntbdflow branch -t release -n \"2.1.0\"\n\n# (This will be named \"fix/PROJ-123-login-bug\" by default)\ntbdflow branch -t fix -n \"login-bug\" --issue \"PROJ-123\"\n\n# Complete a feature branch\ntbdflow complete -t feat -n \"user-profile-page\"\n\n# Complete a release branch (this will be tagged v2.1.0)\ntbdflow complete -t release -n \"2.1.0\"\n```\n\n#### Misc commands\n\n`tbdflow` has a couple of commands that can be beneficial to use but they are not part of the workflow, they are for inspecting the state of the repository.\n\n```bash\n# Does a pull, shows latest changes to main branch, and warns about stale branches.\ntbdflow sync\n\n# Checks the status of the working dir\ntbdflow status\n\n# Shows the current branch name\ntbdflow current-branch\n\n# Explicitly checks for local branches older than one day.\ntbdflow check-branches\n\n# Generate a CHANGELOG\ntbdflow changelog --unreleased\n\n# Do a dry run to see what git commands will be executed\ntbdflow --dry-run sync\n\n# Checks for a new version of tbdflow and updates it if available.\ntbdflow update\n```\n\n### Advanced Usage\n\n#### Shell Completion\n\nTo make `tbdflow` even faster to use, you can enable shell completion. Add one of the following lines to your shell's configuration file.\n\nFor Zsh (`~/.zshrc`):\n\n```bash\neval \"$(tbdflow generate-completion zsh)\"\n```\n\nFor Bash (`~/.bashrc`):\n\n```bash\neval \"$(tbdflow generate-completion bash)\"\n```\n\nFor Fish (`~/.config/fish/config.fish`):\n\n```bash\ntbdflow generate-completion fish | source\n```\n\n#### Man Page Generation\n\nYou can generate a man page for `tbdflow` by running the following command:\n\n```bash\ntbdflow generate-man-page > tbdflow.1\n```\n\n### Development\n\nAll development happens at [tbdflow.git](https://github.com/cladam/tbdflow). Feedback and contributions welcome!\n\n",
      "created_at": "2025-08-23T14:40:30.091677Z",
      "modified_at": "2025-08-27T15:15:14.278022Z"
    },
    {
      "key": "project_medi",
      "title": "project_medi",
      "tags": [],
      "content": "---\nlayout: project\ntitle: \"medi\"\ntagline: \"A speedy CLI driven Markdown manager\"\n---\n\n<p align=\"center\">\n  <img src=\"/assets/images/medi-logo.png\" alt=\"medi logo\" width=\"200\"/>\n</p>\n\n### Overview\n\nA fast, editor-centric, command-line notes manager built in Rust.\n\n`medi` is a powerful tool for creating and managing your notes, articles, and documentation directly from the terminal. It's built for developers, writers, and anyone who loves the speed and focus of a command-line workflow, combining the simplicity of Markdown with the speed of an embedded database.\n\n-----\n\n## Key Features\n\n  - **Speed**: Instant access to any note, no matter how large your collection grows.\n  - **Interactive Fuzzy Finder**: Instantly find and edit any note by its key or title with an interactive `medi find` command.\n  - **Full-Text Search**: Instantly find notes by their content, title, or tags using a powerful built-in search engine.\n  - **Templates for Productivity**: Speed up repetitive writing tasks by creating new notes from custom templates.\n  - **Integrated Task Management**: Turn your notes into actionable to-do lists. Add tasks to any note (`medi task add ...`), list all your pending items, mark them as complete (`medi task done ...`), and set priorities to focus on what's important.\n  - **Status Dashboard**: Get a quick overview of your entire database with the `medi status` command.\n  - **Flexible Input**: Create notes interactively in your editor, with a one-liner `-m` flag, or by piping from other commands.\n  - **Robust Import/Export**: Easily create version-controllable snapshots of your database or import notes from disk.\n  - **Shell Completion**: Generates completion scripts for `bash`, `zsh`, and `fish` for a faster workflow.\n\n-----\n\n## Core Philosophy\n\n`medi` is built on a few guiding principles:\n\n  * **CLI-first**: Everything is done through the terminal. No GUIs, no distractions.\n  * **Editor-centric**: Your text editor (`$EDITOR`) is where you write. `medi` gets you there quickly and saves your work securely.\n  * **Local & private**: All content is stored on your local machine. No cloud services, no network access.\n  * **Zero-config start**: Install it and start writing immediately.\n\n-----\n\n## Technical Details\n\n`medi` is written in **Rust**. It uses `clap` for command-line argument parsing, `sled` for the embedded key-value database and `tantivy` for searching. For the fuzzy finding i am using the `skim` crate.\n\n[**View on GitHub →**](https://github.com/cladam/medi)\n",
      "created_at": "2025-08-14T12:41:54.756838Z",
      "modified_at": "2025-08-27T15:06:45.808834Z"
    },
    {
      "key": "tbdflow",
      "title": "tbdflow",
      "tags": [],
      "content": "tbdflow, a Trunk-Based Development CLI",
      "created_at": "2025-09-01T19:15:55.653778Z",
      "modified_at": "2025-09-01T19:15:55.653779Z"
    },
    {
      "key": "tbdflow-contributing",
      "title": "tbdflow-contributing",
      "tags": [],
      "content": "# Contributing to `tbdflow`\n\nFirst off, thank you for considering contributing to `tbdflow`! It's an open-source project built to help developers, and your help is greatly appreciated. This document will guide you through the process.\n\n## The Philosophy\n\n`tbdflow` is an opinionated tool, and we try to follow our own advice. We practice Trunk-Based Development and use Conventional Commits. While we use Pull Requests to manage contributions from the community (the exact use case they were designed for!), we aim to keep them small, focused, and short-lived.\n\n## How to Contribute\n\nThe best way to contribute is to start a conversation first.\n\n- **Open an Issue**: Before you start writing code, please open an issue to discuss the bug you want to fix or the feature you want to add. This helps us ensure your work aligns with the project's goals and avoids duplicated effort.\n- **Fork and Branch**: Once we've discussed the approach, fork the repository and create a new, short-lived branch for your work.\n- **Write Code & Tests**: Make your changes and be sure to add or update tests to cover your work. We value a robust test suite!\n- **Submit a Pull Request**: Push your branch and open a Pull Request against the `main` branch. Please link the issue you created in the PR description.\n\n## Setting Up Your Development Environment\n\nThe Rust version (`tbdflow-rs`) is the actively developed version.\n\n- **Install Rust**: If you don't have it, install the Rust toolchain from rustup.rs.\n- **Clone the repository**:\n  ```bash\n  git clone https://github.com/cladam/tbdflow.git\n  cd tbdflow/tbdflow-rs\n  ```\n- **Build the project**:\n  ```bash\n  cargo build\n  ```\n\n### Running Tests\nWe have a suite of integration tests to ensure the tool works as expected. Before submitting your changes, please make sure all tests pass.\n\nTo run the full test suite:\n```bash\ncargo test\n```\n\n## Coding Style & Conventions\n\nWe follow the standard Rust coding style. Please run the following commands before committing to ensure your code is formatted correctly and to catch any common issues.\n\nFormat your code:\n```bash\ncargo fmt\n```\n\nRun the linter:\n```bash\ncargo clippy -- -D warnings\n```\n\n## Commit Message Guidelines\n\nWe use `tbdflow` to develop `tbdflow`, so we follow our own rules! All commit messages must follow the Conventional Commits specification. This helps us maintain a clean history and automate our release process.\n\n- Use the imperative mood: \"add feature\" not \"added feature\".\n- Start with a type: feat, fix, docs, chore, refactor, test, etc.\n- Provide a clear description.\n\nThank you again for your interest in contributing!\n",
      "created_at": "2025-08-14T12:41:54.762054Z",
      "modified_at": "2025-08-14T12:41:54.762055Z"
    },
    {
      "key": "tbdflow-dry-run",
      "title": "tbdflow-dry-run",
      "tags": [
        "blogpost"
      ],
      "content": "---\nlayout: post \ntitle: Looking under the hood with a dry-run\n---\n\nOne of the most valuable pieces of feedback I’ve had about `tbdflow` came as a simple question:\n\n**“What does this tool actually do if the user only knows `tbdflow` but not the workflow behind it?”**\n\nIt’s a fair point. The aim of `tbdflow` has never been to act as a magic black box. It’s meant to be a _friendly assistant with guardrails_, helping developers adopt Trunk-Based Development while still showing them what’s going on under the hood.\n\nThat’s why I’ve added a new global flag: `--dry-run`.\n\n### Transparent and educational\n\nWhen you add `--dry-run` to any `tbdflow` command, the tool won’t execute anything. Instead, it prints the exact Git commands it *would* have run, in the order they’d normally run.\n\n- **Transparency**: No hidden steps, no mystery. You see exactly what `tbdflow` is doing for a `commit`, `complete`, or `sync` command. That visibility builds trust and confidence.\n- **Learning**: For anyone new to TBD, `--dry-run` doubles as a teaching tool. By exposing the Git workflow, it shows the “why” behind the automation and helps developers pick up best practices faster.\n\n### How to use it\n\nFor example, if you want to see what happens when creating a new feature branch, just add the `--dry-run` flag:\n\n```bash\ntbdflow --dry-run branch --type feat --name \"new-thing\"\n```\n\nThis will show you every Git command `tbdflow` *would* run, step by step, without actually touching your repo.\n\nThe output looks like this:\n\n```\n[DRY RUN] Command would execute but no changes made\ngit rev-parse --is-inside-work-tree\n\n--- Creating short-lived branch ---\n[DRY RUN] Command would execute but no changes made\ngit status --porcelain\n\n[DRY RUN] Command would execute but no changes made\ngit checkout main\n\n[DRY RUN] Command would execute but no changes made\ngit pull --rebase --autostash\n\n[DRY RUN] Command would execute but no changes made\ngit checkout -b feat/new-thing\n\n[DRY RUN] Command would execute but no changes made\ngit push --set-upstream origin feat/new-thing\n\n```\n\nThis way you get a safe, educational view of how the workflow plays out, without changing a thing.\n\n### Wrapping up\n\n`--dry-run` is a small addition, but it captures the essence of what I want `tbdflow` to be: a helpful assistant that removes friction while staying transparent. It’s there to keep you in flow, but also to show you the ropes so you can deepen your understanding of Git and Trunk-Based Development.\n\nGive it a try, and reveal the magic!\n\n",
      "created_at": "2025-08-23T13:43:38.235213Z",
      "modified_at": "2025-08-23T14:46:25.214257Z"
    },
    {
      "key": "tbdflow-gif-post",
      "title": "tbdflow-gif-post",
      "tags": [],
      "content": "---\nlayout: post\ntitle: How I created the demo GIF for tbdflow\n---\n\nAll projects need a good `README.md`, It’s the front door to the project and it needs to quickly show a potential user what the tool does and why it’s valuable. I put a lot of effort in having a good `README` for `tbdflow` but it was still static text, and the examples was buried deep down.\n\nAfter receiving some great feedback I decided I wanted to put the examples on top and create a GIF of the core workflow.\n\n### The goal; a clean, repeatable demo\n\nMy first thought was to just use a screen recording tool. The problem with live recording is that it’s hard to get perfect. You make typos, you pause for too long, or you have to resize the window. It can be a bit frustrating.\n\nI wanted a way to create a near-perfect, repeatable demo without the stress of a live performance. The solution? A \"tape-driven\" terminal recorder.\n\n### Meet `vhs`, the CLI video recorder 📼 \n\nAfter some research, I landed on [vhs](https://github.com/charmbracelet/vhs). It’s a fantastic tool that generates terminal recordings from a simple script file (a `.tape` file). \nThis was exactly what I was looking for, DSL's are great! With the script I could,\n\n* **Script the entire session**: I could write out every command, every keystroke, and every pause in advance.\n* **Avoid typos**: The demo would be perfect every time.\n* **Control the look and feel**: I could set the font size, window dimensions, and even the colour of the window bar to create a nice, clean GIF.\n\n### From script to GIF\n\n1. **Install the tools needed**\n\n    First install `vhs` using their [guidelines](https://github.com/charmbracelet/vhs?tab=readme-ov-file#installation).\n\n2. **Write the \"Tape\"**\n\n    Next, I created a script file named `commit-demo.tape`. The `vhs` scripting language is simple and intuitive. You just write a series of commands that tell it what to do.\n\nHere’s a snippet from the script that demonstrates the `tbdflow commit` command:\n\n```bash\n# tbdflow-demo.tape\n\n# Set the output file and window properties\nOutput \"commit-demo.gif\"\nSet FontSize 22\nSet Width 1200\nSet Height 800\nSet WindowBar Colorful\n\n# Create a file to commit\nType \"echo 'A new feature' > changes.txt\"\nEnter\nSleep 1s\n\n# Run the tbdflow commit command\nType 'tbdflow commit -t feat -s auth -m \"add password reset endpoint\"'\nEnter\nSleep 1s\n\n# Answer the DoD checklist\n# Use Space to select, Down to move\nSpace\nSleep 500ms\nDown\nSpace\nSleep 500ms\nDown\nSpace\nSleep 500ms\nDown\nSpace\nSleep 500ms\nDown\nSpace\nSleep 1s\n\n# Show the final result\nType 'tbdflow sync'\nEnter\nSleep 5s\n```\n\nSee the full script at [tbdflow-commit.tape](https://github.com/cladam/tbdflow/blob/main/docs/commit-demo.tape).\n\n3. **Generate the GIF**\n\n    This was the easiest part. With the script written, all I had to do was run:\n\n```bash\nvhs commit-demo.tape\n```\n\n`vhs` then automatically opened a terminal, ran my entire scripted demo, and saved the output as a high-quality GIF.\n\n\n### Conclusion\n\nUsing a tool like `vhs` was a amazing. It turned the whole process into a simple, repeatable engineering task. It allowed me to create the demo I wanted and made the examples much more attractive. \n\nCheck it out:\n\n![A terminal running the command tbdflow](https://raw.githubusercontent.com/cladam/tbdflow/main/docs/commit-demo.gif \"A demo of tbdflow running commit-to-main commands\")\n",
      "created_at": "2025-08-16T18:56:51.664906Z",
      "modified_at": "2025-08-17T08:21:21.367419Z"
    },
    {
      "key": "tbdflow-monorepo",
      "title": "tbdflow-monorepo",
      "tags": [],
      "content": "---\nlayout: post\ntitle: tbdflow ❤️ monorepo\ntagline: tbdflow is now \"monorepo-aware\"\n---\n\nMonorepos are a powerful strategy for managing code. By keeping all your projects in a single repository, you get a single source of truth, simplified dependency management, and easier cross-team collaboration. As influencial thought-leaders and others in the DevOps space have pointed out, monorepos are a natural fit for Trunk-Based Development (TBD) because they both revolve around a single, shared mainline of code.\n\nBut with great power comes great responsibility. The biggest challenge of a monorepo is the risk of accidental cross-project changes. How do you commit a change to a root-level `README.md` without accidentally staging unrelated work from the `frontend` and `backend` projects?\n\nThis is exactly the kind of workflow problem that a good tool should solve. That's why tbdflow is now \"monorepo-aware.\"\n\n### The Goal: Safe Commits from Anywhere\n\nThe ideal monorepo workflow should be intuitive and safe. A developer should be able to:\n\n1. Make a change within a specific project (e.g. `frontend/`) and have their commit be automatically scoped to just that project.\n2. Make a change to a shared, root-level file (like `CHANGELOG.md`) and commit it without fear of including unrelated work from other projects.\n\n`tbdflow` now supports this out of the box with a simple configuration.\n\n### How It Works: The `monorepo` Config\nTo enable monorepo mode, you first run `tbdflow init` at the root of your repository. This creates a `.tbdflow.yml` file where you can define your project directories.\n\n```yaml\n# in .tbdflow.yml\nmonorepo:\n  enabled: true\n  # A list of all directories that are self-contained projects.\n  # These will be excluded from root-level commits and status checks.\n  project_dirs:\n    - \"frontend\"\n    - \"backend-api\"\n    - \"infra\"\n```\n\nWith this in place, `tbdflow`'s behavior becomes context-aware:\n\n#### Committing from the Root\n\nWhen you run `tbdflow commit` from the root of the repository, the tool is now smart enough to know it should only stage changes to root-level files. It automatically constructs a `git add` command that excludes all the project directories you've defined.\n\nThis gives you a safe, reliable way to manage your shared, repository-level files.\n\n#### Committing from a Project Directory\n\nTo work within a specific project, you first cd into that directory and run `tbdflow init` again. This creates a new, project-specific `.tbdflow.yml` file that tells `tbdflow` to scope its commands.\n\nNow, when you run `tbdflow commit` from within `frontend/`, the tool behaves as you'd expect. It scopes its `git add .` command to only the `frontend/` directory, ensuring your commit is focused and self-contained.\n\nThe `status` and `sync` commands are also monorepo-aware, giving you a clean, relevant view of your working directory by ignoring other projects when you're at the root.\n\n### Conclusion\n\nTrunk-Based Development and monorepos are a powerful combination for high-performing teams. By adding these new monorepo-aware features, `tbdflow` acts as an intelligent guardrail, helping you and your team get all the benefits of this workflow while avoiding its most common pitfalls.\n\n\n",
      "created_at": "2025-08-28T15:07:11.421899Z",
      "modified_at": "2025-08-28T15:07:11.421901Z"
    },
    {
      "key": "tbdflow-plugin-post",
      "title": "tbdflow-plugin-post",
      "tags": [
        "plugin"
      ],
      "content": "---\nlayout: post\ntitle: Bringing tbdflow to the IDE\ntagline: The tbdflow IntelliJ Plugin \n---\n\nI love the terminal, but yes, most developers live in their IDE. It's their primary workspace, and modern IDEs like IntelliJ have great, integrated Git support. You can stage, commit, push, and manage branches without ever touching the command line.\n\nSo, if the IDE is so good at Git, why build a plugin for [[tbdflow]]?\n\nFirstly because it was a fun exercise 🙂\n\nSecondly, IDEs may understand Git, but they don’t understand _your workflow_. They don't know you practice Trunk-Based Development. They don't know you use Conventional Commits. And they certainly don't know about your team's unique Definition of Done.\n\nI built the IntelliJ plugin to bridge that gap. It's not a replacement for the IDE's Git tools, but an **enhancement** that brings `tbdflow`'s opinionated, TBD-native guardrails to your editor.\n\n### UI-based DevEx\n\nAt the heart of the plugin is the **tbdflow Commit Tool Window**. It provides a structured, non-blocking side panel for crafting the perfect commit:tm:.\n\nThe side panel has two key features:\n\n- **Guided Commit form**: It gives you separate fields for the commit type, scope, message, body, and breaking changes. This makes it easy to create a well-formatted Conventional Commit every single time, without having to remember the exact syntax. This is essentially the `commit` command with most flags included as UI fields.\n- **Native Definition of Done (DoD) checklist**: The plugin automatically reads the checklist from your project's `.dod.yml` file and displays it as a native checklist in the UI. The \"Commit\" button is disabled until you've confirmed that your work meets the team's agreed-upon quality standards. It moves your `DoD` from a document somewhere into an active part of your workflow. \n\nThe `DoD` check is disabled if no `.dod.yml` file exists in the root directory, `tbdflow` is not forcing you to use it.\n\n### Tools --> tbdflow\n\nThe plugin also integrates the other `tbdflow` commands (`branch`, `complete`, `sync`, etc.) into the IDE’s **Tools** menu. That means you can follow your team’s workflow without breaking flow by switching to the terminal.\n\n### The friendly assistant, IDE-enabled\n\nThe goal of `tbdflow` has always been to be a \"friendly assistant\" that makes the right way the easy way. This plugin brings that assistant directly into the environment where developers spend most of their time.\n\nIt's available on [JetBrains Marketplace](https://plugins.jetbrains.com/plugin/28339-tbdflow), and in the IDE just search for `tbdflow`. BTW, most of JetBrains products are supported, not just IntelliJ. I personally use it in RustRover.\n\nYou can explore the source code in the tbdflow monorepo at [tbdflow/plugins/intellij](https://github.com/cladam/tbdflow/tree/main/plugins/intellij)\n\n\n",
      "created_at": "2025-08-31T11:46:21.531770Z",
      "modified_at": "2025-09-02T07:33:21.837061Z"
    },
    {
      "key": "tbdflow-readme",
      "title": "tbdflow-readme",
      "tags": [],
      "content": "<div align=\"center\">\n  <p align=\"center\">\n    <img src=\"assets/tbdflow-logo.png\" alt=\"tbdflow logo\" width=\"200\"/>\n  </p>\n\n  <p align=\"center\">\n    <i><b>Keep your code flowing</b></i><br/>\n  </p>\n\n[![Crates.io](https://img.shields.io/crates/v/tbdflow.svg)](https://crates.io/crates/tbdflow)\n[![Downloads](https://img.shields.io/crates/d/tbdflow.svg)](https://crates.io/crates/tbdflow)\n\n</div>\n\n## tbdflow, a Trunk-Based Development CLI\n\n`tbdflow` is a lightweight command-line tool that helps you (and your team) stay in flow with Trunk-Based Development (TBD).\n\nThis CLI supports both the default commit-to-main workflow and the structured handling of short-lived branches for features, releases, and hotfixes.\n\n![A terminal running the command tbdflowlow](docs/commit-demo.gif \"A demo of tbdflow running commit-to-main commands\")\n\n## Philosophy\n\nThis tool is built around a specific philosophy of Trunk-Based Development:\n\n* **Main is the default.** The `commit` command is your everyday go-to. It automates pulling the latest changes, committing, and pushing directly to `main`, promoting small, frequent integrations.\n* **Branches are the exception.** While branches are supported, they’re treated as short-lived exceptions and not the norm.\n* **Cleanup is automatic.** The complete command enforces branch short-livedness by merging and automatically tagging (release) and deleting completed branches, helping keep your repo tidy.\n* **Conventional Commits encouraged.** Commit messages follow [Conventional Commits](https://www.conventionalcommits.org/) for clarity and consistency.\n\n### Why not just use Git?\n\nThis CLI isn’t a replacement for Git. You’ll still reach for raw `git` when doing advanced work like rebasing, cherry-picking, or running `git bisect`.\n\nThis tool is as a **workflow assistant**, `tbdflow` encapsulates a repeatable, opinionated process to support your day-to-day development.\n\nIt offers three main benefits:\n\n1. **Consistency across the team**\n   Everyone follows the same steps for common tasks. Commits, branches, and releases are handled the same way every time, keeping your Git history clean and predictable.\n\n2. **Less to remember**\n   No need to recall the exact flags or sequences (like `pull --rebase`, `merge --no-ff`, or commit message formats). The CLI handles that, so you can stay focused on writing code.\n\n3. **It supports \"the TBD way\"**\n   This tool makes the preferred approach easy by providing a smooth, safe, and efficient path for 80% of everyday tasks. For the other 20%, you can always use Git directly.\n\n### Installation\n\nYou need [Rust and Cargo](https://www.rust-lang.org/tools/install) installed.\n\n#### Installing from crates.io\n\nThe easiest way to install `tbdflow` is to download it from [crates.io](https://crates.io/crates/tbdflow). You can do it using the following command:\n\n```bash\ncargo install tbdflow\n```\n\nIf you want to update `tbdflow` to the latest version, execute the following command:\n\n```bash\ntbdflow update\n```\n\n#### Building from source\n\nAlternatively you can build `tbdflow` from source using Cargo:\n\n```bash\ngit clone https://github.com/cladam/tbdflow.git\ncd tbdflow\nsudo cargo install --path . --root /usr/local\n```\n\n### Monorepo Support\n`tbdflow` is \"monorepo-aware.\" It understands that in a monorepo, you often want commands to be scoped to a specific project or subdirectory.\n\nWhen you run `tbdflow commit`, `tbdflow sync` or `tbdflow status` from the root of a configured monorepo, the tool will intelligently ignore project subdirectories, making sure you only commit changes to root-level files (like `README.md`, `LICENSE`, or `CI configuration`). When run from within a project subdirectory, the commands are automatically scoped to just that directory (**N.B.** you need to run `tbdflow init` from within the subdirectory for this to work).\n\nThis is configured in your root `.tbdflow.yml` file:\n```\n# in .tbdflow.yml\nmonorepo:\nenabled: true\n  # A list of all directories that are self-contained projects.\n  # These will be excluded from root-level commits and status checks.\n  project_dirs:\n    - \"frontend\"\n    - \"backend-api\"\n    - \"infra\"\n```\n\n#### Handling Cross-Cutting Changes\nFor \"vertical slice\" changes that intentionally touch multiple project directories, you can use the `--include-projects` flag. This flag overrides the default safety mechanism and stages all changes from all directories, allowing you to create a single, cross-cutting commit.\n\n### Configuration\n`tbdflow` is configurable via two optional files in the root of your repository. To get started quickly, run `tbdflow init` to generate default versions of these files.\n\n`.tbdflow.yml`\nThis file controls the core workflow of the tool. You can customise:\n- The name of your main branch (e.g. main, trunk).\n- Allowed branch types and their prefixes (e.g feat/, chore/)\n- A strategy for handling issue references (\"branch-name\" or \"commit-scope\")\n- The threshold for stale branch warnings.\n- Automatic tagging formats.\n- Commit message linting rules.\n\n`.dod.yml`\nThis file controls the interactive Definition of Done checklist for the commit command. \n\n### Features\n\n#### The Definition of Done (DoD) Check\nTo move beyond just automating process, `tbdflow` integrates an optional pre-commit quality check. If a `.dod.yml` file is present in your repository, the commit command will present an interactive checklist to ensure your work meets the team's agreed-upon standards.\n\n**Example** `.dod.yml`:\n\n```\n# .dod.yml in your project root\nchecklist:\n  - \"All relevant automated tests pass successfully.\"\n  - \"New features or fixes are covered by new tests.\"\n  - \"Security implications of this change have been considered.\"\n  - \"Relevant documentation (code comments, READMEs) is updated.\"\n```\n\nIf you try to proceed without checking all items, the tool will offer to add a TODO list to your commit message footer, ensuring the incomplete work is tracked directly in your Git history.\n\n#### Commit Message Linting\n\nIf a `.tbdflow.yml` file is present and contains a lint section, the commit command will automatically validate your commit message against the configured rules before the DoD check. This provides immediate feedback on stylistic and structural conventions.\n\n**Default linting rules:**\n\n```yaml\nlint:\n  conventional_commit_type:\n    enabled: true\n    allowed_types:\n    - build\n    - chore\n    - ci\n    - docs\n    - feat\n    - fix\n    - perf\n    - refactor\n    - revert\n    - style\n    - test\n  issue_key_missing:\n    enabled: false\n    pattern: ^[A-Z]+-\\d+$\n  scope:\n    enabled: true\n    enforce_lowercase: true\n  subject_line_rules:\n    max_length: 72\n    enforce_lowercase: true\n    no_period: true\n  body_line_rules:\n    max_line_length: 80\n    leading_blank: true\n```\n---\n\n## Global options\n\n| Flag        | Description                                              | Required |\n|-------------|----------------------------------------------------------|----------|\n| --verbose   | Prints the underlying Git commands as they are executed. | No       |\n| --dry-run   | Simulate the command without making any changes.         | No       |\n\n## Commands\n\n### 1. `commit`\n\nThis is the primary command for daily work.\n\nCommits staged changes using a Conventional Commits message. This command is context-aware:\n* **On `main`:** It runs the full TBD workflow: pulls the latest changes with rebase, commits, and pushes.\n* **On any other branch:** It simply commits and pushes, allowing you to save work-in-progress.\n\n\n**Usage:**\n\n```bash\ntbdflow commit [options]\n```\n\n**Options:**\n\n| Flag | Option                  | Description                                              | Required |\n|------|-------------------------|----------------------------------------------------------|----------|\n| -t   | --type                  | The type of commit (e.g., feat, fix, chore).             | Yes      |\n| -s   | --scope                 | The scope of the changes (e.g., api, ui).                | No       |\n| -m   | --message               | The descriptive commit message (subject line).           | Yes      |\n|      | --body                  | Optional multi-line body for the commit message.         | No       |\n| -b   | --breaking              | Mark the commit as a breaking change.                    | No       |\n|      | --breaking-description  | Provide a description for the 'BREAKING CHANGE:' footer. | No       |\n|      | --tag                   | Optionally add and push an annotated tag to this commit. | No       |\n|      | --issue                 | Optionally add an issue reference to the footer.         | No       |\n|      | --no-verify             | Bypass the interactive DoD checklist.                    | No       |\n\n**Example:**\n\n```bash\n# A new feature\ntbdflow commit -t feat -s auth -m \"add password reset endpoint\"\n\n# A bug fix with a breaking change\ntbdflow commit -t fix -m \"correct user permission logic\" -b\ntbdflow commit -t refactor -m \"rename internal API\" --breaking --breaking-description \"The `getUser` function has been renamed to `fetchUser`.\"\n\n# A bug fix with a new tag\ntbdflow commit -t fix -m \"correct user permission logic\" --tag \"v1.1.1\"\n```\n\n### 2. `branch`\n\nCreates and pushes a new, short-lived branch from the latest version of `main`. This is the primary command for starting new work that isn't a direct commit to `main`.\n\n**Usage:**\n\n```bash\ntbdflow branch --type <type> --name <name> [--issue <issue-id>] [--from_commit <commit hash>]\n```\n\n**Options (release):**\n\n| Flag              | Description                                                                     | Required |\n|-------------------|---------------------------------------------------------------------------------|----------|\n| -t, --type        | The type of branch (e.g. feat, fix, chore). See .tbdflow.yml for allowed types. | Yes      |\n| -n, --name        | A short, desriptive name for the branch.                                        | Yes      |\n| --issue           | Optional issue reference to include in the branch name or commit scope.         | No       |\n| -f, --from_commit | Optional commit hash on `main` to branch from.                                  | No       |\n\n\n**Examples:**\n\n```bash\n# Create a simple feature branch named \"feat/new-dashboard\"\ntbdflow branch -t feat -n \"new-dashboard\"\n\n# Create a fix branch with an issue reference in the name\n# (This will be named \"fix/PROJ-123-login-bug\" by default)\ntbdflow branch -t fix -n \"login-bug\" --issue \"PROJ-123\"\n\n# Create a release branch from a specific commit\ntbdflow branch -t release -v \"2.1.0\" -f \"39b68b5\"\n```\n\n### 3. `complete`\n\nMerges a short-lived branch back into main, then deletes the local and remote copies of the branch.\n\n**Automatic Tagging:**\n\n* When completing a release branch, a tag (e.g. v2.1.0) is automatically created and pushed.\n\n**Usage:**\n\n```bash\ntbdflow complete --type <branch-type> --name <branch-name>\n```\n\n**Options:**\n\n| Flag | Option   | Description                                             | Required |\n|------|----------|---------------------------------------------------------|----------|\n| -t   | --type   | The type of branch: feature, release, or hotfix.        | Yes      |\n| -n   | --name   | The name or version of the branch to complete.          | Yes      |\n\n**Examples:**\n\n```bash\n# Complete a feature branch\ntbdflow complete -t feat -n \"user-profile-page\"\n\n# Complete a release branch (this will be tagged v2.1.0)\ntbdflow complete -t release -n \"2.1.0\"\n```\n\n### 4. `changelog`\n\nGenerates a changelog in Markdown format from your repository's Conventional Commit history. See `tbdflow` repo for a CHANGELOG.md generated by this command.\n\n**Usage:**\n\n```bash\ntbdflow changelog [options]\n```\n\n**Options:**\n\n| Option        | Description                                                               |\n|---------------|---------------------------------------------------------------------------|\n| --unreleased  | Generate a changelog for all commits since the last tag.                  |\n| --from        | Generate a changelog for commits from a specific tag.                     |\n| --to          | Generate a changelog for commits up to a specific tag (defaults to HEAD). |\n\n**Examples:**\n\n```bash\n# Generate a changelog for a new version\ntbdflow changelog --from v0.12.0 --to v0.13.0\n\n# See what will be in the next release\ntbdflow changelog --unreleased\n```\n\n### 5. Utility commands\n\n`tbdflow` has a couple of commands that can be beneficial to use but they are not part of the workflow, they are for inspecting the state of the repository. \n\n**Examples:**\n\n```bash\n# Does a pull, shows latest changes to main branch, and warns about stale branches.\ntbdflow sync\n\n# Checks the status of the working dir\ntbdflow status\n\n# Shows the current branch name\ntbdflow current-branch\n\n# Explicitly checks for local branches older than one day.\ntbdflow check-branches\n\n# Checks for a new version of tbdflow and updates it if available.\ntbdflow update\n```\n\n### 6. Advanced Usage\n\n#### Shell Completion\n\nTo make `tbdflow` even faster to use, you can enable shell completion. Add one of the following lines to your shell's configuration file.\n\nFor Zsh (`~/.zshrc`):\n\n```bash\neval \"$(tbdflow generate-completion zsh)\"\n```\n\nFor Bash (`~/.bashrc`):\n\n```bash\neval \"$(tbdflow generate-completion bash)\"\n```\n\nFor Fish (`~/.config/fish/config.fish`):\n\n```bash\ntbdflow generate-completion fish | source\n```\n\n#### Man Page Generation\n\nYou can generate a man page for `tbdflow` by running the following command:\n\n```bash\ntbdflow generate-man-page > tbdflow.1\n```\n\n",
      "created_at": "2025-08-25T06:57:13.843400Z",
      "modified_at": "2025-08-29T16:39:28.885121Z"
    }
  ]
}
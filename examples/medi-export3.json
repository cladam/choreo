{
  "export_date": "2025-09-15T05:05:22.081772Z",
  "note_count": 22,
  "notes": [
    {
      "key": "choreo-reference",
      "title": "choreo-reference",
      "tags": [],
      "content": "# Choreo DSL Reference\n\n**choreo** is an executable Domain-Specific Language (DSL) for writing automated, behaviour-driven tests for command-line applications and system interactions. It uses a structured, human-readable format to define test scenarios that are easy to write, read, and maintain.\n\nThis document serves as the official reference guide for the `.chor` file format and its syntax.\n\n## File Structure: The BDD Hierarchy\n\nA `.chor` file is structured hierarchically to tell a clear story, following the standard BDD pattern of `Feature -> Scenario -> Test`.\n\n```\nfeature \"A high-level description of the capability being tested\"\n\n# ... (settings, vars, actors)\n\nscenario \"A concrete example of the feature's behaviour\" {\n\n    test TestNameOne \"The first step in the scenario\" {  \n        given:  \n            # Pre-conditions and setup actions  \n        when:  \n            # The single action being tested  \n        then:  \n            # The expected outcomes and assertions  \n    }\n\n    test TestNameTwo \"The second step, depending on the first\" {  \n        given:  \n            Test has_succeeded TestNameOne  \n        # ... and so on  \n    }\n\n    after {  \n        # Cleanup actions that run after all tests in this scenario  \n    }  \n}\n```\n\n## Keywords\n\n`choreo` uses a set of keywords to define the structure and logic of a test suite.\n\n#### `feature`\n\nProvides a high-level description of the software capability being tested and groups related scenarios. A `.chor` file should contain exactly one `feature`.\n\n**Example:**\n\n```\nfeature \"User account management via the CLI\"\n```\n\n#### `settings`\n\nA block for configuring the behaviour of the `choreo` test runner for the current file.\n\n**Example:**\n```\nsettings:  \n  timeout_seconds = 60  \n  stop_on_failure = true  \n  shell_path = \"/bin/bash\"  \n  report_path = \"test-results/\"\n```\n\n#### `vars`\n\nA block for defining key-value variables that can be used throughout the test file. This is useful for making tests more readable and maintainable by avoiding \"magic strings.\"\n\n**Example:**\n```\nvars:  \n  FILENAME = \"my_output.txt\"  \n  GREETING = \"Hello, Choreo!\"\n```\n\n#### `env`\n\nDeclares a list of environment variables that the test suite requires. The test runner will read these from the shell environment where `choreo` is executed and make them available for substitution.\n\n**Example:**\n```\nenv: API_TOKEN, GITHUB_USER\n```\n\n#### `actors`\n\nDeclares the different systems or components that the test will interact with. The two currently supported actors are `Terminal` and `FileSystem`.\n\n**Example:**\n```\nactors: Terminal, FileSystem\n```\n\n#### `scenario`\n\nDescribes a single, concrete example of the feature's behaviour. It acts as a container for a sequence of related `test` blocks that form a user story or workflow.\n\n**Example:**\n```\nscenario \"A user can successfully create and then delete a file\" {  \n    # ... test blocks go here ...  \n}\n```\n\n#### `test`\n\nThe core unit of testing in `choreo`. Each `test` block has a unique name (for dependencies) and a human-readable description. It is composed of `given`, `when`, and `then` blocks.\n\n**Example:**\n```\ntest FileIsCreated \"it creates a new file with content\" {  \n    given: # ...  \n    when:  # ...  \n    then:  # ...  \n}\n```\n\n#### `after`\n\nAn optional block inside a `scenario` that contains a list of cleanup actions. These actions are executed after all `test` blocks within that scenario have completed, regardless of whether they passed or failed.\n\n**Example:**\n```\nscenario \"...\" {  \n    # ... tests ...\n\n    after {  \n        FileSystem delete_file \"${FILENAME}\"  \n    }  \n}\n```\n\n## Test Blocks: Given, When, Then\n\nEach `test` block is structured using the standard BDD keywords to create a clear narrative.\n\n#### `given`:\n\nThe `given` block sets up the context for a test. It can contain a mix of **actions** (to set up the environment) and **conditions** (to check pre-requisites, including dependencies on other tests).\n\n**Example:**\n```\ngiven:  \n    # Action: Ensure a clean state  \n    FileSystem delete_file \"data.txt\"  \n    # Condition: This test can only run after the setup test has passed  \n    Test has_succeeded InitialSetup\n```\n\n#### `when`:\n\nThe `when` block contains the single, specific action that is being tested. A `when` block should contain only actions, not conditions.\n\n**Example:**\n```\nwhen:  \n    Terminal runs \"data-processor --input data.txt\"\n```\n\n#### `then`:\n\nThe `then` block contains the assertions that verify the outcome of the `when` action. A `then` block should contain only conditions. The test passes if all `then` conditions are met.\n\n**Example:**\n```\nthen:  \n    Terminal last_command succeeded  \n    FileSystem file_exists \"output.txt\"\n```\n\n## Vocabulary: Actions & Conditions\n\nThis is the reference for all available commands that can be used within the `test` blocks.\n\n### Wait Conditions\n\n| Syntax | Description |\n| :---- | :---- |\n| `wait \\>= 1.5s` | Passes if the test has been running for at least 1.5 seconds. |\n| `wait \\<= 100ms` | Passes if the test has been running for no more than 100 milliseconds. |\n\n### State Conditions\n\n| Syntax                        | Description |\n|:------------------------------| :---- |\n| `Test has_succeeded <TestName>` | Passes if the test with the given name has already passed. This is the primary mechanism for creating dependencies. |\n\n### Terminal Commands\n\n#### Actions\n\n| Syntax | Description                                                                             |\n| :---- |:----------------------------------------------------------------------------------------|\n| `Terminal runs \"...\"` | Executes a shell command non-interactively. The command and a newline are sent at once. |\n| `Terminal types \"...\"` | Simulates a user typing a string into the terminal.                                     |\n| `Terminal presses \"Enter\"` | Simulates a user pressing the Enter key.                                                |\n\n#### Conditions\n\n| Syntax                                     | Description                                                                        |\n|:-------------------------------------------|:-----------------------------------------------------------------------------------|\n| `Terminal last_command succeeded`          | Passes if the last `Terminal runs` command exited with code 0.                     |\n| `Terminal last_command failed`             | Passes if the last `Terminal runs` command exited with a non-zero code.            |\n| `Terminal last_command exit_code_is <num>` | Passes if the last `Terminal runs` command exited with the specified code.           |\n| `Terminal output_contains \"...\"`           | Passes if the combined stdout/stderr stream from the PTY contains the substring.   |\n| `Terminal stdout_is_empty`                 | Passes if the stdout from the last `Terminal runs` command was empty.                |\n| `Terminal stderr_contains \"...\"`           | Passes if the stderr from the last `Terminal runs` command contains the substring.   |\n| `Terminal output_starts_with \"...\"`        | Passes if the trimmed stdout of the last `runs` command starts with the string.      |\n| `Terminal output_ends_with \"...\"`          | Passes if the trimmed stdout of the last `runs` command ends with the string.        |\n| `Terminal output_equals \"...\"`             | Passes if the trimmed stdout of the last `runs` command is an exact match.           |\n| `Terminal output_matches \"...\"`            | Passes if the combined stdout/stderr stream from the PTY matches the regex.        |\n\n### FileSystem Commands\n\n#### Actions\n\n| Syntax                                          | Description |\n|:------------------------------------------------| :---- |\n| `FileSystem create_dir \"...\"`                     | Creates a directory, including any necessary parent directories. |\n| `FileSystem create_file \"...\"`                    | Creates an empty file. |\n| `FileSystem create_file \"...\" with_content \"...\"` | Creates a file and writes the specified content to it. |\n| `FileSystem delete_dir \"...\"`                     | Deletes a directory and all its contents. |\n| `FileSystem delete_file \"...\"`                    | Deletes a file. |\n\n#### Conditions\n\n| Syntax                                 | Description |\n|:---------------------------------------| :---- |\n| `FileSystem dir_exists \"...\"`          | Passes if a directory exists at the specified path. |\n| `FileSystem file_exists \"...\"`         | Passes if a file exists at the specified path. |\n| `FileSystem file_does_not_exist \"...\"`  | Passes if nothing exists at the specified path. |\n| `FileSystem file_contains \"...\" \"...\"`  | Passes if the file at the first path contains the second string. |\n\n## Variables\n\n`choreo` supports both environment variables and file-defined variables for making tests dynamic.\n\n### Substitution\n\nTo use a variable, use the `${VAR_NAME}` syntax inside any string literal. The test runner will replace this placeholder with the variable's value before executing the step.\n\n**Example:**\n```\nvars:  \n  FILENAME = \"output.log\"  \nwhen:  \n  Terminal runs \"echo 'hello' > ${FILENAME}\"  \n```\n\n",
      "created_at": "2025-09-12T12:03:44.571663Z",
      "modified_at": "2025-09-12T12:03:44.571664Z"
    },
    {
      "key": "choreo-test",
      "title": "choreo-test",
      "tags": [],
      "content": "# My quick medi note",
      "created_at": "2025-09-15T05:05:21.390316Z",
      "modified_at": "2025-09-15T05:05:21.390316Z"
    }
  ]
}
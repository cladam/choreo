// choreo - A DSL for defining interactive test scenarios.
// This grammar defines the DSL structure and syntax.

// Ignore whitespace and comments.
WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT    = _{ "#" ~ (!NEWLINE ~ ANY)* }

// The program is a series of statements.
grammar = { SOI ~ statement* ~ EOI }
statement = { settings_def | env_def | actors_def | outcomes_def | rule }

// Setting up the test suite.
settings_def = { "settings:" ~ setting+ }
setting      = { identifier ~ value }

env_def = { "env:" ~ identifier ~ ("," ~ identifier)* }
output_matches_condition = { identifier ~ "output_matches" ~ string ~ ("as" ~ identifier)? }

actors_def   = { "actors:" ~ identifier ~ ("," ~ identifier)* }
outcomes_def = { "outcomes:" ~ identifier ~ ("," ~ identifier)* }

// The core of the testing logic.
rule = { "rule" ~ string ~ "{" ~ when_block ~ then_block ~ "}" }

when_block = { "when:" ~ condition+ }
then_block = { "then:" ~ action+ }

// The "if" part of a rule.
condition = { time_condition | output_condition | state_condition | output_matches_condition}

time_condition = { "time" ~ WHITESPACE* ~ comparison_op ~ WHITESPACE* ~ time_marker }
output_condition = { identifier ~ "output_contains" ~ string }
state_condition  = { "Test" ~ "has_succeeded" ~ identifier }

// The "do this" part of a rule.
action = { type_action | press_action | run_action | test_action }

type_action  = { identifier ~ "types" ~ string }
press_action = { identifier ~ "presses" ~ string }
run_action   = { identifier ~ "runs" ~ string }
test_action  = { "Test" ~ "succeeds" ~ identifier }

// The basic building blocks of the language.
//identifier    = @{('a'..'z' | 'A'..'Z' | "_" ) ~ ('a'..'z' | 'A'..'Z' | '0'..'9' | '_')* }
identifier = @{ ( "_" | 'a'..'z' | 'A'..'Z' ) ~ ( "_" | 'a'..'z' | 'A'..'Z' | '0'..'9' )* }
string = { "\"" ~ inner_double ~ "\"" | "'" ~ inner_single ~ "'" }
// These are the parts your Rust parser will actually capture.
inner_double = @{ (!"\"" ~ ANY)* }
inner_single = @{ (!"'" ~ ANY)* }
number        = { ('0'..'9')+ }
time_marker   = @{ number ~ "s" }
value         = { string | number }
comparison_op = @{ ">=" | "<=" | "==" | ">" | "<" }
